// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f deploy/clusters/aws1/components/postgres-crds/postgres-crds.gen.yaml

package v1beta1

import "strings"

// PostgresCluster is the Schema for the postgresclusters API
#PostgresCluster: {
	// APIVersion defines the versioned schema of this representation
	// of an object. Servers should convert recognized schemas to the
	// latest internal value, and may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "postgres-operator.crunchydata.com/v1beta1"

	// Kind is a string value representing the REST resource this
	// object represents. Servers may infer this from the endpoint
	// the client submits requests to. Cannot be updated. In
	// CamelCase. More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "PostgresCluster"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// PostgresClusterSpec defines the desired state of
	// PostgresCluster
	spec!: #PostgresClusterSpec
}

// PostgresClusterSpec defines the desired state of
// PostgresCluster
#PostgresClusterSpec: {
	backups: {
		// pgBackRest archive configuration
		pgbackrest: {
			// Projected volumes containing custom pgBackRest configuration.
			// These files are mounted under "/etc/pgbackrest/conf.d"
			// alongside any pgBackRest configuration generated by the
			// PostgreSQL Operator: https://pgbackrest.org/configuration.html
			configuration?: [...{
				// configMap information about the configMap data to project
				configMap?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced ConfigMap will be projected into the volume as
					// a file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the ConfigMap, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional specify whether the ConfigMap or its keys must be
					// defined
					optional?: bool
				}
				downwardAPI?: {
					// Items is a list of DownwardAPIVolume file
					items?: [...{
						// Required: Selects a field of the pod: only annotations, labels,
						// name and namespace are supported.
						fieldRef?: {
							// Version of the schema the FieldPath is written in terms of,
							// defaults to "v1".
							apiVersion?: string

							// Path of the field to select in the specified API version.
							fieldPath: string
						}

						// Optional: mode bits used to set permissions on this file, must
						// be an octal value between 0000 and 0777 or a decimal value
						// between 0 and 511. YAML accepts both octal and decimal values,
						// JSON requires decimal values for mode bits. If not specified,
						// the volume defaultMode will be used. This might be in conflict
						// with other options that affect the file mode, like fsGroup,
						// and the result can be other mode bits set.
						mode?: int

						// Required: Path is the relative path name of the file to be
						// created. Must not be absolute or contain the '..' path. Must
						// be utf-8 encoded. The first item of the relative path must not
						// start with '..'
						path: string

						// Selects a resource of the container: only resources limits and
						// requests (limits.cpu, limits.memory, requests.cpu and
						// requests.memory) are currently supported.
						resourceFieldRef?: {
							// Container name: required for volumes, optional for env vars
							containerName?: string

							// Specifies the output format of the exposed resources, defaults
							// to "1"
							divisor?: (int | string) & {
								=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Required: resource to select
							resource: string
						}
					}]
				}

				// secret information about the secret data to project
				secret?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced Secret will be projected into the volume as a
					// file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the Secret, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional field specify whether the Secret or its key must be
					// defined
					optional?: bool
				}

				// serviceAccountToken is information about the
				// serviceAccountToken data to project
				serviceAccountToken?: {
					// audience is the intended audience of the token. A recipient of
					// a token must identify itself with an identifier specified in
					// the audience of the token, and otherwise should reject the
					// token. The audience defaults to the identifier of the
					// apiserver.
					audience?: string

					// expirationSeconds is the requested duration of validity of the
					// service account token. As the token approaches expiration, the
					// kubelet volume plugin will proactively rotate the service
					// account token. The kubelet will start trying to rotate the
					// token if the token is older than 80 percent of its time to
					// live or if the token is older than 24 hours.Defaults to 1 hour
					// and must be at least 10 minutes.
					expirationSeconds?: int

					// path is the path relative to the mount point of the file to
					// project the token into.
					path: string
				}
			}]

			// Global pgBackRest configuration settings. These settings are
			// included in the "global" section of the pgBackRest
			// configuration generated by the PostgreSQL Operator, and then
			// mounted under "/etc/pgbackrest/conf.d":
			// https://pgbackrest.org/configuration.html
			global?: {
				[string]: string
			}

			// The image name to use for pgBackRest containers. Utilized to
			// run pgBackRest repository hosts and backups. The image may
			// also be set using the RELATED_IMAGE_PGBACKREST environment
			// variable
			image?: string

			// Jobs field allows configuration for all backup jobs
			jobs?: {
				// Scheduling constraints of pgBackRest backup Job pods. More
				// info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
				affinity?: {
					// Describes node affinity scheduling rules for the pod.
					nodeAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node matches the
						// corresponding matchExpressions; the node(s) with the highest
						// sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// A node selector term, associated with the corresponding weight.
							preference: {
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}

							// Weight associated with matching the corresponding
							// nodeSelectorTerm, in the range 1-100.
							weight: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							// Required. A list of node selector terms. The terms are ORed.
							nodeSelectorTerms: [...{
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}]
						}
					}

					// Describes pod affinity scheduling rules (e.g. co-locate this
					// pod in the same node, zone, etc. as some other pod(s)).
					podAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node has pods which matches
						// the corresponding podAffinityTerm; the node(s) with the
						// highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the affinity requirements specified by this field are not
						// met at scheduling time, the pod will not be scheduled onto the
						// node. If the affinity requirements specified by this field
						// cease to be met at some point during pod execution (e.g. due
						// to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}

					// Describes pod anti-affinity scheduling rules (e.g. avoid
					// putting this pod in the same node, zone, etc. as some other
					// pod(s)).
					podAntiAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the anti-affinity expressions specified by this field,
						// but it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling anti-affinity expressions, etc.),
						// compute a sum by iterating through the elements of this field
						// and adding "weight" to the sum if the node has pods which
						// matches the corresponding podAffinityTerm; the node(s) with
						// the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the anti-affinity requirements specified by this field are
						// not met at scheduling time, the pod will not be scheduled onto
						// the node. If the anti-affinity requirements specified by this
						// field cease to be met at some point during pod execution (e.g.
						// due to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}
				}

				// Priority class name for the pgBackRest backup Job pods. More
				// info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
				priorityClassName?: string

				// Resource limits for backup jobs. Includes manual, scheduled and
				// replica create backups
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// Tolerations of pgBackRest backup Job pods. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
				tolerations?: [...{
					// Effect indicates the taint effect to match. Empty means match
					// all taint effects. When specified, allowed values are
					// NoSchedule, PreferNoSchedule and NoExecute.
					effect?: string

					// Key is the taint key that the toleration applies to. Empty
					// means match all taint keys. If the key is empty, operator must
					// be Exists; this combination means to match all values and all
					// keys.
					key?: string

					// Operator represents a key's relationship to the value. Valid
					// operators are Exists and Equal. Defaults to Equal. Exists is
					// equivalent to wildcard for value, so that a pod can tolerate
					// all taints of a particular category.
					operator?: string

					// TolerationSeconds represents the period of time the toleration
					// (which must be of effect NoExecute, otherwise this field is
					// ignored) tolerates the taint. By default, it is not set, which
					// means tolerate the taint forever (do not evict). Zero and
					// negative values will be treated as 0 (evict immediately) by
					// the system.
					tolerationSeconds?: int

					// Value is the taint value the toleration matches to. If the
					// operator is Exists, the value should be empty, otherwise just
					// a regular string.
					value?: string
				}]

				// Limit the lifetime of a Job that has finished. More info:
				// https://kubernetes.io/docs/concepts/workloads/controllers/job
				ttlSecondsAfterFinished?: >=60 & int
			}

			// Defines details for manual pgBackRest backup Jobs
			manual?: {
				// Command line options to include when running the pgBackRest
				// backup command.
				// https://pgbackrest.org/command.html#command-backup
				options?: [...string]

				// The name of the pgBackRest repo to run the backup command
				// against.
				repoName: =~"^repo[1-4]"
			}

			// Metadata contains metadata for custom resources
			metadata?: {
				annotations?: {
					[string]: string
				}
				labels?: {
					[string]: string
				}
			}

			// Defines configuration for a pgBackRest dedicated repository
			// host. This section is only applicable if at least one "volume"
			// (i.e. PVC-based) repository is defined in the "repos" section,
			// therefore enabling a dedicated repository host Deployment.
			repoHost?: {
				// Scheduling constraints of the Dedicated repo host pod. Changing
				// this value causes repo host to restart. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
				affinity?: {
					// Describes node affinity scheduling rules for the pod.
					nodeAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node matches the
						// corresponding matchExpressions; the node(s) with the highest
						// sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// A node selector term, associated with the corresponding weight.
							preference: {
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}

							// Weight associated with matching the corresponding
							// nodeSelectorTerm, in the range 1-100.
							weight: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							// Required. A list of node selector terms. The terms are ORed.
							nodeSelectorTerms: [...{
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}]
						}
					}

					// Describes pod affinity scheduling rules (e.g. co-locate this
					// pod in the same node, zone, etc. as some other pod(s)).
					podAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node has pods which matches
						// the corresponding podAffinityTerm; the node(s) with the
						// highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the affinity requirements specified by this field are not
						// met at scheduling time, the pod will not be scheduled onto the
						// node. If the affinity requirements specified by this field
						// cease to be met at some point during pod execution (e.g. due
						// to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}

					// Describes pod anti-affinity scheduling rules (e.g. avoid
					// putting this pod in the same node, zone, etc. as some other
					// pod(s)).
					podAntiAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the anti-affinity expressions specified by this field,
						// but it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling anti-affinity expressions, etc.),
						// compute a sum by iterating through the elements of this field
						// and adding "weight" to the sum if the node has pods which
						// matches the corresponding podAffinityTerm; the node(s) with
						// the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the anti-affinity requirements specified by this field are
						// not met at scheduling time, the pod will not be scheduled onto
						// the node. If the anti-affinity requirements specified by this
						// field cease to be met at some point during pod execution (e.g.
						// due to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}
				}

				// Priority class name for the pgBackRest repo host pod. Changing
				// this value causes PostgreSQL to restart. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
				priorityClassName?: string

				// Resource requirements for a pgBackRest repository host
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// ConfigMap containing custom SSH configuration. Deprecated:
				// Repository hosts use mTLS for encryption, authentication, and
				// authorization.
				sshConfigMap?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced ConfigMap will be projected into the volume as
					// a file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the ConfigMap, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional specify whether the ConfigMap or its keys must be
					// defined
					optional?: bool
				}

				// Secret containing custom SSH keys. Deprecated: Repository hosts
				// use mTLS for encryption, authentication, and authorization.
				sshSecret?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced Secret will be projected into the volume as a
					// file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the Secret, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional field specify whether the Secret or its key must be
					// defined
					optional?: bool
				}

				// Tolerations of a PgBackRest repo host pod. Changing this value
				// causes a restart. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
				tolerations?: [...{
					// Effect indicates the taint effect to match. Empty means match
					// all taint effects. When specified, allowed values are
					// NoSchedule, PreferNoSchedule and NoExecute.
					effect?: string

					// Key is the taint key that the toleration applies to. Empty
					// means match all taint keys. If the key is empty, operator must
					// be Exists; this combination means to match all values and all
					// keys.
					key?: string

					// Operator represents a key's relationship to the value. Valid
					// operators are Exists and Equal. Defaults to Equal. Exists is
					// equivalent to wildcard for value, so that a pod can tolerate
					// all taints of a particular category.
					operator?: string

					// TolerationSeconds represents the period of time the toleration
					// (which must be of effect NoExecute, otherwise this field is
					// ignored) tolerates the taint. By default, it is not set, which
					// means tolerate the taint forever (do not evict). Zero and
					// negative values will be treated as 0 (evict immediately) by
					// the system.
					tolerationSeconds?: int

					// Value is the taint value the toleration matches to. If the
					// operator is Exists, the value should be empty, otherwise just
					// a regular string.
					value?: string
				}]

				// Topology spread constraints of a Dedicated repo host pod.
				// Changing this value causes the repo host to restart. More
				// info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
				topologySpreadConstraints?: [...{
					// LabelSelector is used to find matching pods. Pods that match
					// this label selector are counted to determine the number of
					// pods in their corresponding topology domain.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// MaxSkew describes the degree to which pods may be unevenly
					// distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the
					// maximum permitted difference between the number of matching
					// pods in the target topology and the global minimum. The global
					// minimum is the minimum number of matching pods in an eligible
					// domain or zero if the number of eligible domains is less than
					// MinDomains. For example, in a 3-zone cluster, MaxSkew is set
					// to 1, and pods with the same labelSelector spread as 2/2/1: In
					// this case, the global minimum is 1. | zone1 | zone2 | zone3 |
					// | P P | P P | P | - if MaxSkew is 1, incoming pod can only be
					// scheduled to zone3 to become 2/2/2; scheduling it onto
					// zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
					// violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be
					// scheduled onto any zone. When
					// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
					// precedence to topologies that satisfy it. It's a required
					// field. Default value is 1 and 0 is not allowed.
					maxSkew: int

					// MinDomains indicates a minimum number of eligible domains. When
					// the number of eligible domains with matching topology keys is
					// less than minDomains, Pod Topology Spread treats "global
					// minimum" as 0, and then the calculation of Skew is performed.
					// And when the number of eligible domains with matching topology
					// keys equals or greater than minDomains, this value has no
					// effect on scheduling. As a result, when the number of eligible
					// domains is less than minDomains, scheduler won't schedule more
					// than maxSkew Pods to those domains. If value is nil, the
					// constraint behaves as if MinDomains is equal to 1. Valid
					// values are integers greater than 0. When value is not nil,
					// WhenUnsatisfiable must be DoNotSchedule.
					// For example, in a 3-zone cluster, MaxSkew is set to 2,
					// MinDomains is set to 5 and pods with the same labelSelector
					// spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P |
					// The number of domains is less than 5(MinDomains), so "global
					// minimum" is treated as 0. In this situation, new pod with the
					// same labelSelector cannot be scheduled, because computed skew
					// will be 3(3 - 0) if new Pod is scheduled to any of the three
					// zones, it will violate MaxSkew.
					// This is an alpha field and requires enabling
					// MinDomainsInPodTopologySpread feature gate.
					minDomains?: int

					// TopologyKey is the key of node labels. Nodes that have a label
					// with this key and identical values are considered to be in the
					// same topology. We consider each <key, value> as a "bucket",
					// and try to put balanced number of pods into each bucket. We
					// define a domain as a particular instance of a topology. Also,
					// we define an eligible domain as a domain whose nodes match the
					// node selector. e.g. If TopologyKey is
					// "kubernetes.io/hostname", each Node is a domain of that
					// topology. And, if TopologyKey is
					// "topology.kubernetes.io/zone", each zone is a domain of that
					// topology. It's a required field.
					topologyKey: string

					// WhenUnsatisfiable indicates how to deal with a pod if it
					// doesn't satisfy the spread constraint. - DoNotSchedule
					// (default) tells the scheduler not to schedule it. -
					// ScheduleAnyway tells the scheduler to schedule the pod in any
					// location, but giving higher precedence to topologies that
					// would help reduce the skew. A constraint is considered
					// "Unsatisfiable" for an incoming pod if and only if every
					// possible node assignment for that pod would violate "MaxSkew"
					// on some topology. For example, in a 3-zone cluster, MaxSkew is
					// set to 1, and pods with the same labelSelector spread as
					// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If
					// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
					// only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
					// ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other
					// words, the cluster can still be imbalanced, but scheduler
					// won't make it *more* imbalanced. It's a required field.
					whenUnsatisfiable: string
				}]
			}

			// Defines a pgBackRest repository
			repos: [...{
				azure?: {
					// The Azure container utilized for the repository
					container: string
				}
				gcs?: {
					// The GCS bucket utilized for the repository
					bucket: string
				}

				// The name of the the repository
				name: =~"^repo[1-4]"

				// RepoS3 represents a pgBackRest repository that is created using
				// AWS S3 (or S3-compatible) storage
				s3?: {
					// The S3 bucket utilized for the repository
					bucket: string

					// A valid endpoint corresponding to the specified region
					endpoint: string

					// The region corresponding to the S3 bucket
					region: string
				}

				// Defines the schedules for the pgBackRest backups Full,
				// Differential and Incremental backup types are supported:
				// https://pgbackrest.org/user-guide.html#concept/backup
				schedules?: {
					// Defines the Cron schedule for a differential pgBackRest backup.
					// Follows the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					differential?: strings.MinRunes(6)

					// Defines the Cron schedule for a full pgBackRest backup. Follows
					// the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					full?: strings.MinRunes(6)

					// Defines the Cron schedule for an incremental pgBackRest backup.
					// Follows the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					incremental?: strings.MinRunes(6)
				}
				volume?: {
					// Defines a PersistentVolumeClaim spec used to create and/or bind
					// a volume
					volumeClaimSpec: {
						// accessModes contains the desired access modes the volume should
						// have. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
						accessModes: [...string] & [_, ...]

						// dataSource field can be used to specify either: * An existing
						// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
						// * An existing PVC (PersistentVolumeClaim) If the provisioner
						// or an external controller can support the specified data
						// source, it will create a new volume based on the contents of
						// the specified data source. If the AnyVolumeDataSource feature
						// gate is enabled, this field will always have the same contents
						// as the DataSourceRef field.
						dataSource?: {
							// APIGroup is the group for the resource being referenced. If
							// APIGroup is not specified, the specified Kind must be in the
							// core API group. For any other third-party types, APIGroup is
							// required.
							apiGroup?: string

							// Kind is the type of resource being referenced
							kind: string

							// Name is the name of resource being referenced
							name: string
						}

						// dataSourceRef specifies the object from which to populate the
						// volume with data, if a non-empty volume is desired. This may
						// be any local object from a non-empty API group (non core
						// object) or a PersistentVolumeClaim object. When this field is
						// specified, volume binding will only succeed if the type of the
						// specified object matches some installed volume populator or
						// dynamic provisioner. This field will replace the functionality
						// of the DataSource field and as such if both fields are
						// non-empty, they must have the same value. For backwards
						// compatibility, both fields (DataSource and DataSourceRef) will
						// be set to the same value automatically if one of them is empty
						// and the other is non-empty. There are two important
						// differences between DataSource and DataSourceRef: * While
						// DataSource only allows two specific types of objects,
						// DataSourceRef allows any non-core object, as well as
						// PersistentVolumeClaim objects. * While DataSource ignores
						// disallowed values (dropping them), DataSourceRef preserves all
						// values, and generates an error if a disallowed value is
						// specified. (Beta) Using this field requires the
						// AnyVolumeDataSource feature gate to be enabled.
						dataSourceRef?: {
							// APIGroup is the group for the resource being referenced. If
							// APIGroup is not specified, the specified Kind must be in the
							// core API group. For any other third-party types, APIGroup is
							// required.
							apiGroup?: string

							// Kind is the type of resource being referenced
							kind: string

							// Name is the name of resource being referenced
							name: string
						}

						// resources represents the minimum resources the volume should
						// have. If RecoverVolumeExpansionFailure feature is enabled
						// users are allowed to specify resource requirements that are
						// lower than previous value but must still be higher than
						// capacity recorded in the status field of the claim. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
						resources: {
							// Limits describes the maximum amount of compute resources
							// allowed. More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							limits?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Requests describes the minimum amount of compute resources
							// required. If Requests is omitted for a container, it defaults
							// to Limits if that is explicitly specified, otherwise to an
							// implementation-defined value. More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							requests: {
								{
									[!~"^(storage)$"]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}
								storage: _
							}
						}

						// selector is a label query over volumes to consider for binding.
						selector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// storageClassName is the name of the StorageClass required by
						// the claim. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
						storageClassName?: string

						// volumeMode defines what type of volume is required by the
						// claim. Value of Filesystem is implied when not included in
						// claim spec.
						volumeMode?: string

						// volumeName is the binding reference to the PersistentVolume
						// backing this claim.
						volumeName?: string
					}
				}
			}] & [_, ...]

			// Defines details for performing an in-place restore using
			// pgBackRest
			restore?: {
				// Scheduling constraints of the pgBackRest restore Job. More
				// info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
				affinity?: {
					// Describes node affinity scheduling rules for the pod.
					nodeAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node matches the
						// corresponding matchExpressions; the node(s) with the highest
						// sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// A node selector term, associated with the corresponding weight.
							preference: {
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}

							// Weight associated with matching the corresponding
							// nodeSelectorTerm, in the range 1-100.
							weight: int
						}]
						requiredDuringSchedulingIgnoredDuringExecution?: {
							// Required. A list of node selector terms. The terms are ORed.
							nodeSelectorTerms: [...{
								// A list of node selector requirements by node's labels.
								matchExpressions?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]

								// A list of node selector requirements by node's fields.
								matchFields?: [...{
									// The label key that the selector applies to.
									key: string

									// Represents a key's relationship to a set of values. Valid
									// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
									operator: string

									// An array of string values. If the operator is In or NotIn, the
									// values array must be non-empty. If the operator is Exists or
									// DoesNotExist, the values array must be empty. If the operator
									// is Gt or Lt, the values array must have a single element,
									// which will be interpreted as an integer. This array is
									// replaced during a strategic merge patch.
									values?: [...string]
								}]
							}]
						}
					}

					// Describes pod affinity scheduling rules (e.g. co-locate this
					// pod in the same node, zone, etc. as some other pod(s)).
					podAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the affinity expressions specified by this field, but
						// it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling affinity expressions, etc.), compute
						// a sum by iterating through the elements of this field and
						// adding "weight" to the sum if the node has pods which matches
						// the corresponding podAffinityTerm; the node(s) with the
						// highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the affinity requirements specified by this field are not
						// met at scheduling time, the pod will not be scheduled onto the
						// node. If the affinity requirements specified by this field
						// cease to be met at some point during pod execution (e.g. due
						// to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}

					// Describes pod anti-affinity scheduling rules (e.g. avoid
					// putting this pod in the same node, zone, etc. as some other
					// pod(s)).
					podAntiAffinity?: {
						// The scheduler will prefer to schedule pods to nodes that
						// satisfy the anti-affinity expressions specified by this field,
						// but it may choose a node that violates one or more of the
						// expressions. The node that is most preferred is the one with
						// the greatest sum of weights, i.e. for each node that meets all
						// of the scheduling requirements (resource request,
						// requiredDuringScheduling anti-affinity expressions, etc.),
						// compute a sum by iterating through the elements of this field
						// and adding "weight" to the sum if the node has pods which
						// matches the corresponding podAffinityTerm; the node(s) with
						// the highest sum are the most preferred.
						preferredDuringSchedulingIgnoredDuringExecution?: [...{
							// Required. A pod affinity term, associated with the
							// corresponding weight.
							podAffinityTerm: {
								// A label query over a set of resources, in this case pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// A label query over the set of namespaces that the term applies
								// to. The term is applied to the union of the namespaces
								// selected by this field and the ones listed in the namespaces
								// field. null selector and null or empty namespaces list means
								// "this pod's namespace". An empty selector ({}) matches all
								// namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn, the values array must be non-empty. If the operator is
										// Exists or DoesNotExist, the values array must be empty. This
										// array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels map is equivalent to an element of
									// matchExpressions, whose key field is "key", the operator is
									// "In", and the values array contains only "value". The
									// requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to. The term is applied to the union of the
								// namespaces listed in this field and the ones selected by
								// namespaceSelector. null or empty namespaces list and null
								// namespaceSelector means "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching the labelSelector in
								// the specified namespaces, where co-located is defined as
								// running on a node whose value of the label with key
								// topologyKey matches that of any node on which any of the
								// selected pods is running. Empty topologyKey is not allowed.
								topologyKey: string
							}

							// weight associated with matching the corresponding
							// podAffinityTerm, in the range 1-100.
							weight: int
						}]

						// If the anti-affinity requirements specified by this field are
						// not met at scheduling time, the pod will not be scheduled onto
						// the node. If the anti-affinity requirements specified by this
						// field cease to be met at some point during pod execution (e.g.
						// due to a pod label update), the system may or may not try to
						// eventually evict the pod from its node. When there are
						// multiple elements, the lists of nodes corresponding to each
						// podAffinityTerm are intersected, i.e. all terms must be
						// satisfied.
						requiredDuringSchedulingIgnoredDuringExecution?: [...{
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}]
					}
				}

				// The name of an existing PostgresCluster to use as the data
				// source for the new PostgresCluster. Defaults to the name of
				// the PostgresCluster being created if not provided.
				clusterName?: string

				// The namespace of the cluster specified as the data source using
				// the clusterName field. Defaults to the namespace of the
				// PostgresCluster being created if not provided.
				clusterNamespace?: string

				// Whether or not in-place pgBackRest restores are enabled for
				// this PostgresCluster.
				enabled: bool | *false

				// Command line options to include when running the pgBackRest
				// restore command.
				// https://pgbackrest.org/command.html#command-restore
				options?: [...string]

				// Priority class name for the pgBackRest restore Job pod.
				// Changing this value causes PostgreSQL to restart. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
				priorityClassName?: string

				// The name of the pgBackRest repo within the source
				// PostgresCluster that contains the backups that should be
				// utilized to perform a pgBackRest restore when initializing the
				// data source for the new PostgresCluster.
				repoName: =~"^repo[1-4]"

				// Resource requirements for the pgBackRest restore Job.
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// Tolerations of the pgBackRest restore Job. More info:
				// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
				tolerations?: [...{
					// Effect indicates the taint effect to match. Empty means match
					// all taint effects. When specified, allowed values are
					// NoSchedule, PreferNoSchedule and NoExecute.
					effect?: string

					// Key is the taint key that the toleration applies to. Empty
					// means match all taint keys. If the key is empty, operator must
					// be Exists; this combination means to match all values and all
					// keys.
					key?: string

					// Operator represents a key's relationship to the value. Valid
					// operators are Exists and Equal. Defaults to Equal. Exists is
					// equivalent to wildcard for value, so that a pod can tolerate
					// all taints of a particular category.
					operator?: string

					// TolerationSeconds represents the period of time the toleration
					// (which must be of effect NoExecute, otherwise this field is
					// ignored) tolerates the taint. By default, it is not set, which
					// means tolerate the taint forever (do not evict). Zero and
					// negative values will be treated as 0 (evict immediately) by
					// the system.
					tolerationSeconds?: int

					// Value is the taint value the toleration matches to. If the
					// operator is Exists, the value should be empty, otherwise just
					// a regular string.
					value?: string
				}]
			}

			// Configuration for pgBackRest sidecar containers
			sidecars?: {
				pgbackrest?: {
					// Resource requirements for a sidecar container
					resources?: {
						// Limits describes the maximum amount of compute resources
						// allowed. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required. If Requests is omitted for a container, it defaults
						// to Limits if that is explicitly specified, otherwise to an
						// implementation-defined value. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}
				}
				pgbackrestConfig?: {
					// Resource requirements for a sidecar container
					resources?: {
						// Limits describes the maximum amount of compute resources
						// allowed. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required. If Requests is omitted for a container, it defaults
						// to Limits if that is explicitly specified, otherwise to an
						// implementation-defined value. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}
				}
			}
		}
	}
	config?: {
		files?: [...{
			// configMap information about the configMap data to project
			configMap?: {
				// items if unspecified, each key-value pair in the Data field of
				// the referenced ConfigMap will be projected into the volume as
				// a file whose name is the key and content is the value. If
				// specified, the listed keys will be projected into the
				// specified paths, and unlisted keys will not be present. If a
				// key is specified which is not present in the ConfigMap, the
				// volume setup will error unless it is marked optional. Paths
				// must be relative and may not contain the '..' path or start
				// with '..'.
				items?: [...{
					// key is the key to project.
					key: string

					// mode is Optional: mode bits used to set permissions on this
					// file. Must be an octal value between 0000 and 0777 or a
					// decimal value between 0 and 511. YAML accepts both octal and
					// decimal values, JSON requires decimal values for mode bits. If
					// not specified, the volume defaultMode will be used. This might
					// be in conflict with other options that affect the file mode,
					// like fsGroup, and the result can be other mode bits set.
					mode?: int

					// path is the relative path of the file to map the key to. May
					// not be an absolute path. May not contain the path element
					// '..'. May not start with the string '..'.
					path: string
				}]

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// optional specify whether the ConfigMap or its keys must be
				// defined
				optional?: bool
			}
			downwardAPI?: {
				// Items is a list of DownwardAPIVolume file
				items?: [...{
					// Required: Selects a field of the pod: only annotations, labels,
					// name and namespace are supported.
					fieldRef?: {
						// Version of the schema the FieldPath is written in terms of,
						// defaults to "v1".
						apiVersion?: string

						// Path of the field to select in the specified API version.
						fieldPath: string
					}

					// Optional: mode bits used to set permissions on this file, must
					// be an octal value between 0000 and 0777 or a decimal value
					// between 0 and 511. YAML accepts both octal and decimal values,
					// JSON requires decimal values for mode bits. If not specified,
					// the volume defaultMode will be used. This might be in conflict
					// with other options that affect the file mode, like fsGroup,
					// and the result can be other mode bits set.
					mode?: int

					// Required: Path is the relative path name of the file to be
					// created. Must not be absolute or contain the '..' path. Must
					// be utf-8 encoded. The first item of the relative path must not
					// start with '..'
					path: string

					// Selects a resource of the container: only resources limits and
					// requests (limits.cpu, limits.memory, requests.cpu and
					// requests.memory) are currently supported.
					resourceFieldRef?: {
						// Container name: required for volumes, optional for env vars
						containerName?: string

						// Specifies the output format of the exposed resources, defaults
						// to "1"
						divisor?: (int | string) & {
							=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Required: resource to select
						resource: string
					}
				}]
			}

			// secret information about the secret data to project
			secret?: {
				// items if unspecified, each key-value pair in the Data field of
				// the referenced Secret will be projected into the volume as a
				// file whose name is the key and content is the value. If
				// specified, the listed keys will be projected into the
				// specified paths, and unlisted keys will not be present. If a
				// key is specified which is not present in the Secret, the
				// volume setup will error unless it is marked optional. Paths
				// must be relative and may not contain the '..' path or start
				// with '..'.
				items?: [...{
					// key is the key to project.
					key: string

					// mode is Optional: mode bits used to set permissions on this
					// file. Must be an octal value between 0000 and 0777 or a
					// decimal value between 0 and 511. YAML accepts both octal and
					// decimal values, JSON requires decimal values for mode bits. If
					// not specified, the volume defaultMode will be used. This might
					// be in conflict with other options that affect the file mode,
					// like fsGroup, and the result can be other mode bits set.
					mode?: int

					// path is the relative path of the file to map the key to. May
					// not be an absolute path. May not contain the path element
					// '..'. May not start with the string '..'.
					path: string
				}]

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// optional field specify whether the Secret or its key must be
				// defined
				optional?: bool
			}

			// serviceAccountToken is information about the
			// serviceAccountToken data to project
			serviceAccountToken?: {
				// audience is the intended audience of the token. A recipient of
				// a token must identify itself with an identifier specified in
				// the audience of the token, and otherwise should reject the
				// token. The audience defaults to the identifier of the
				// apiserver.
				audience?: string

				// expirationSeconds is the requested duration of validity of the
				// service account token. As the token approaches expiration, the
				// kubelet volume plugin will proactively rotate the service
				// account token. The kubelet will start trying to rotate the
				// token if the token is older than 80 percent of its time to
				// live or if the token is older than 24 hours.Defaults to 1 hour
				// and must be at least 10 minutes.
				expirationSeconds?: int

				// path is the path relative to the mount point of the file to
				// project the token into.
				path: string
			}
		}]
	}

	// The secret containing the replication client certificates and
	// keys for secure connections to the PostgreSQL server. It will
	// need to contain the client TLS certificate, TLS key and the
	// Certificate Authority certificate with the data keys set to
	// tls.crt, tls.key and ca.crt, respectively. NOTE: If
	// CustomReplicationClientTLSSecret is provided, CustomTLSSecret
	// MUST be provided and the ca.crt provided must be the same.
	customReplicationTLSSecret?: {
		// items if unspecified, each key-value pair in the Data field of
		// the referenced Secret will be projected into the volume as a
		// file whose name is the key and content is the value. If
		// specified, the listed keys will be projected into the
		// specified paths, and unlisted keys will not be present. If a
		// key is specified which is not present in the Secret, the
		// volume setup will error unless it is marked optional. Paths
		// must be relative and may not contain the '..' path or start
		// with '..'.
		items?: [...{
			// key is the key to project.
			key: string

			// mode is Optional: mode bits used to set permissions on this
			// file. Must be an octal value between 0000 and 0777 or a
			// decimal value between 0 and 511. YAML accepts both octal and
			// decimal values, JSON requires decimal values for mode bits. If
			// not specified, the volume defaultMode will be used. This might
			// be in conflict with other options that affect the file mode,
			// like fsGroup, and the result can be other mode bits set.
			mode?: int

			// path is the relative path of the file to map the key to. May
			// not be an absolute path. May not contain the path element
			// '..'. May not start with the string '..'.
			path: string
		}]

		// Name of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string

		// optional field specify whether the Secret or its key must be
		// defined
		optional?: bool
	}

	// The secret containing the Certificates and Keys to encrypt
	// PostgreSQL traffic will need to contain the server TLS
	// certificate, TLS key and the Certificate Authority certificate
	// with the data keys set to tls.crt, tls.key and ca.crt,
	// respectively. It will then be mounted as a volume projection
	// to the '/pgconf/tls' directory. For more information on
	// Kubernetes secret projections, please see
	// https://k8s.io/docs/concepts/configuration/secret/#projection-of-secret-keys-to-specific-paths
	// NOTE: If CustomTLSSecret is provided,
	// CustomReplicationClientTLSSecret MUST be provided and the
	// ca.crt provided must be the same.
	customTLSSecret?: {
		// items if unspecified, each key-value pair in the Data field of
		// the referenced Secret will be projected into the volume as a
		// file whose name is the key and content is the value. If
		// specified, the listed keys will be projected into the
		// specified paths, and unlisted keys will not be present. If a
		// key is specified which is not present in the Secret, the
		// volume setup will error unless it is marked optional. Paths
		// must be relative and may not contain the '..' path or start
		// with '..'.
		items?: [...{
			// key is the key to project.
			key: string

			// mode is Optional: mode bits used to set permissions on this
			// file. Must be an octal value between 0000 and 0777 or a
			// decimal value between 0 and 511. YAML accepts both octal and
			// decimal values, JSON requires decimal values for mode bits. If
			// not specified, the volume defaultMode will be used. This might
			// be in conflict with other options that affect the file mode,
			// like fsGroup, and the result can be other mode bits set.
			mode?: int

			// path is the relative path of the file to map the key to. May
			// not be an absolute path. May not contain the path element
			// '..'. May not start with the string '..'.
			path: string
		}]

		// Name of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string

		// optional field specify whether the Secret or its key must be
		// defined
		optional?: bool
	}

	// Specifies a data source for bootstrapping the PostgreSQL
	// cluster.
	dataSource?: {
		// Defines a pgBackRest cloud-based data source that can be used
		// to pre-populate the the PostgreSQL data directory for a new
		// PostgreSQL cluster using a pgBackRest restore. The PGBackRest
		// field is incompatible with the PostgresCluster field: only one
		// data source can be used for pre-populating a new PostgreSQL
		// cluster
		pgbackrest?: {
			// Scheduling constraints of the pgBackRest restore Job. More
			// info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node matches the
					// corresponding matchExpressions; the node(s) with the highest
					// sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node has pods which matches
					// the corresponding podAffinityTerm; the node(s) with the
					// highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at scheduling time, the pod will not be scheduled onto the
					// node. If the affinity requirements specified by this field
					// cease to be met at some point during pod execution (e.g. due
					// to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the anti-affinity expressions specified by this field,
					// but it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling anti-affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding "weight" to the sum if the node has pods which
					// matches the corresponding podAffinityTerm; the node(s) with
					// the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at scheduling time, the pod will not be scheduled onto
					// the node. If the anti-affinity requirements specified by this
					// field cease to be met at some point during pod execution (e.g.
					// due to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// Projected volumes containing custom pgBackRest configuration.
			// These files are mounted under "/etc/pgbackrest/conf.d"
			// alongside any pgBackRest configuration generated by the
			// PostgreSQL Operator: https://pgbackrest.org/configuration.html
			configuration?: [...{
				// configMap information about the configMap data to project
				configMap?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced ConfigMap will be projected into the volume as
					// a file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the ConfigMap, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional specify whether the ConfigMap or its keys must be
					// defined
					optional?: bool
				}
				downwardAPI?: {
					// Items is a list of DownwardAPIVolume file
					items?: [...{
						// Required: Selects a field of the pod: only annotations, labels,
						// name and namespace are supported.
						fieldRef?: {
							// Version of the schema the FieldPath is written in terms of,
							// defaults to "v1".
							apiVersion?: string

							// Path of the field to select in the specified API version.
							fieldPath: string
						}

						// Optional: mode bits used to set permissions on this file, must
						// be an octal value between 0000 and 0777 or a decimal value
						// between 0 and 511. YAML accepts both octal and decimal values,
						// JSON requires decimal values for mode bits. If not specified,
						// the volume defaultMode will be used. This might be in conflict
						// with other options that affect the file mode, like fsGroup,
						// and the result can be other mode bits set.
						mode?: int

						// Required: Path is the relative path name of the file to be
						// created. Must not be absolute or contain the '..' path. Must
						// be utf-8 encoded. The first item of the relative path must not
						// start with '..'
						path: string

						// Selects a resource of the container: only resources limits and
						// requests (limits.cpu, limits.memory, requests.cpu and
						// requests.memory) are currently supported.
						resourceFieldRef?: {
							// Container name: required for volumes, optional for env vars
							containerName?: string

							// Specifies the output format of the exposed resources, defaults
							// to "1"
							divisor?: (int | string) & {
								=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Required: resource to select
							resource: string
						}
					}]
				}

				// secret information about the secret data to project
				secret?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced Secret will be projected into the volume as a
					// file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the Secret, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional field specify whether the Secret or its key must be
					// defined
					optional?: bool
				}

				// serviceAccountToken is information about the
				// serviceAccountToken data to project
				serviceAccountToken?: {
					// audience is the intended audience of the token. A recipient of
					// a token must identify itself with an identifier specified in
					// the audience of the token, and otherwise should reject the
					// token. The audience defaults to the identifier of the
					// apiserver.
					audience?: string

					// expirationSeconds is the requested duration of validity of the
					// service account token. As the token approaches expiration, the
					// kubelet volume plugin will proactively rotate the service
					// account token. The kubelet will start trying to rotate the
					// token if the token is older than 80 percent of its time to
					// live or if the token is older than 24 hours.Defaults to 1 hour
					// and must be at least 10 minutes.
					expirationSeconds?: int

					// path is the path relative to the mount point of the file to
					// project the token into.
					path: string
				}
			}]

			// Global pgBackRest configuration settings. These settings are
			// included in the "global" section of the pgBackRest
			// configuration generated by the PostgreSQL Operator, and then
			// mounted under "/etc/pgbackrest/conf.d":
			// https://pgbackrest.org/configuration.html
			global?: {
				[string]: string
			}

			// Command line options to include when running the pgBackRest
			// restore command.
			// https://pgbackrest.org/command.html#command-restore
			options?: [...string]

			// Priority class name for the pgBackRest restore Job pod.
			// Changing this value causes PostgreSQL to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
			priorityClassName?: string

			// Defines a pgBackRest repository
			repo: {
				azure?: {
					// The Azure container utilized for the repository
					container: string
				}
				gcs?: {
					// The GCS bucket utilized for the repository
					bucket: string
				}

				// The name of the the repository
				name: =~"^repo[1-4]"

				// RepoS3 represents a pgBackRest repository that is created using
				// AWS S3 (or S3-compatible) storage
				s3?: {
					// The S3 bucket utilized for the repository
					bucket: string

					// A valid endpoint corresponding to the specified region
					endpoint: string

					// The region corresponding to the S3 bucket
					region: string
				}

				// Defines the schedules for the pgBackRest backups Full,
				// Differential and Incremental backup types are supported:
				// https://pgbackrest.org/user-guide.html#concept/backup
				schedules?: {
					// Defines the Cron schedule for a differential pgBackRest backup.
					// Follows the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					differential?: strings.MinRunes(6)

					// Defines the Cron schedule for a full pgBackRest backup. Follows
					// the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					full?: strings.MinRunes(6)

					// Defines the Cron schedule for an incremental pgBackRest backup.
					// Follows the standard Cron schedule syntax:
					// https://k8s.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax
					incremental?: strings.MinRunes(6)
				}
				volume?: {
					// Defines a PersistentVolumeClaim spec used to create and/or bind
					// a volume
					volumeClaimSpec: {
						// accessModes contains the desired access modes the volume should
						// have. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
						accessModes?: [...string]

						// dataSource field can be used to specify either: * An existing
						// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
						// * An existing PVC (PersistentVolumeClaim) If the provisioner
						// or an external controller can support the specified data
						// source, it will create a new volume based on the contents of
						// the specified data source. If the AnyVolumeDataSource feature
						// gate is enabled, this field will always have the same contents
						// as the DataSourceRef field.
						dataSource?: {
							// APIGroup is the group for the resource being referenced. If
							// APIGroup is not specified, the specified Kind must be in the
							// core API group. For any other third-party types, APIGroup is
							// required.
							apiGroup?: string

							// Kind is the type of resource being referenced
							kind: string

							// Name is the name of resource being referenced
							name: string
						}

						// dataSourceRef specifies the object from which to populate the
						// volume with data, if a non-empty volume is desired. This may
						// be any local object from a non-empty API group (non core
						// object) or a PersistentVolumeClaim object. When this field is
						// specified, volume binding will only succeed if the type of the
						// specified object matches some installed volume populator or
						// dynamic provisioner. This field will replace the functionality
						// of the DataSource field and as such if both fields are
						// non-empty, they must have the same value. For backwards
						// compatibility, both fields (DataSource and DataSourceRef) will
						// be set to the same value automatically if one of them is empty
						// and the other is non-empty. There are two important
						// differences between DataSource and DataSourceRef: * While
						// DataSource only allows two specific types of objects,
						// DataSourceRef allows any non-core object, as well as
						// PersistentVolumeClaim objects. * While DataSource ignores
						// disallowed values (dropping them), DataSourceRef preserves all
						// values, and generates an error if a disallowed value is
						// specified. (Beta) Using this field requires the
						// AnyVolumeDataSource feature gate to be enabled.
						dataSourceRef?: {
							// APIGroup is the group for the resource being referenced. If
							// APIGroup is not specified, the specified Kind must be in the
							// core API group. For any other third-party types, APIGroup is
							// required.
							apiGroup?: string

							// Kind is the type of resource being referenced
							kind: string

							// Name is the name of resource being referenced
							name: string
						}

						// resources represents the minimum resources the volume should
						// have. If RecoverVolumeExpansionFailure feature is enabled
						// users are allowed to specify resource requirements that are
						// lower than previous value but must still be higher than
						// capacity recorded in the status field of the claim. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
						resources?: {
							// Limits describes the maximum amount of compute resources
							// allowed. More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							limits?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Requests describes the minimum amount of compute resources
							// required. If Requests is omitted for a container, it defaults
							// to Limits if that is explicitly specified, otherwise to an
							// implementation-defined value. More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							requests?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}
						}

						// selector is a label query over volumes to consider for binding.
						selector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// storageClassName is the name of the StorageClass required by
						// the claim. More info:
						// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
						storageClassName?: string

						// volumeMode defines what type of volume is required by the
						// claim. Value of Filesystem is implied when not included in
						// claim spec.
						volumeMode?: string

						// volumeName is the binding reference to the PersistentVolume
						// backing this claim.
						volumeName?: string
					}
				}
			}

			// Resource requirements for the pgBackRest restore Job.
			resources?: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// The name of an existing pgBackRest stanza to use as the data
			// source for the new PostgresCluster. Defaults to `db` if not
			// provided.
			stanza: string | *"db"

			// Tolerations of the pgBackRest restore Job. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects. When specified, allowed values are
				// NoSchedule, PreferNoSchedule and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys. If the key is empty, operator must
				// be Exists; this combination means to match all values and all
				// keys.
				key?: string

				// Operator represents a key's relationship to the value. Valid
				// operators are Exists and Equal. Defaults to Equal. Exists is
				// equivalent to wildcard for value, so that a pod can tolerate
				// all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be of effect NoExecute, otherwise this field is
				// ignored) tolerates the taint. By default, it is not set, which
				// means tolerate the taint forever (do not evict). Zero and
				// negative values will be treated as 0 (evict immediately) by
				// the system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to. If the
				// operator is Exists, the value should be empty, otherwise just
				// a regular string.
				value?: string
			}]
		}

		// Defines a pgBackRest data source that can be used to
		// pre-populate the PostgreSQL data directory for a new
		// PostgreSQL cluster using a pgBackRest restore. The PGBackRest
		// field is incompatible with the PostgresCluster field: only one
		// data source can be used for pre-populating a new PostgreSQL
		// cluster
		postgresCluster?: {
			// Scheduling constraints of the pgBackRest restore Job. More
			// info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node matches the
					// corresponding matchExpressions; the node(s) with the highest
					// sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node has pods which matches
					// the corresponding podAffinityTerm; the node(s) with the
					// highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at scheduling time, the pod will not be scheduled onto the
					// node. If the affinity requirements specified by this field
					// cease to be met at some point during pod execution (e.g. due
					// to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the anti-affinity expressions specified by this field,
					// but it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling anti-affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding "weight" to the sum if the node has pods which
					// matches the corresponding podAffinityTerm; the node(s) with
					// the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at scheduling time, the pod will not be scheduled onto
					// the node. If the anti-affinity requirements specified by this
					// field cease to be met at some point during pod execution (e.g.
					// due to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// The name of an existing PostgresCluster to use as the data
			// source for the new PostgresCluster. Defaults to the name of
			// the PostgresCluster being created if not provided.
			clusterName?: string

			// The namespace of the cluster specified as the data source using
			// the clusterName field. Defaults to the namespace of the
			// PostgresCluster being created if not provided.
			clusterNamespace?: string

			// Command line options to include when running the pgBackRest
			// restore command.
			// https://pgbackrest.org/command.html#command-restore
			options?: [...string]

			// Priority class name for the pgBackRest restore Job pod.
			// Changing this value causes PostgreSQL to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
			priorityClassName?: string

			// The name of the pgBackRest repo within the source
			// PostgresCluster that contains the backups that should be
			// utilized to perform a pgBackRest restore when initializing the
			// data source for the new PostgresCluster.
			repoName: =~"^repo[1-4]"

			// Resource requirements for the pgBackRest restore Job.
			resources?: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// Tolerations of the pgBackRest restore Job. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects. When specified, allowed values are
				// NoSchedule, PreferNoSchedule and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys. If the key is empty, operator must
				// be Exists; this combination means to match all values and all
				// keys.
				key?: string

				// Operator represents a key's relationship to the value. Valid
				// operators are Exists and Equal. Defaults to Equal. Exists is
				// equivalent to wildcard for value, so that a pod can tolerate
				// all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be of effect NoExecute, otherwise this field is
				// ignored) tolerates the taint. By default, it is not set, which
				// means tolerate the taint forever (do not evict). Zero and
				// negative values will be treated as 0 (evict immediately) by
				// the system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to. If the
				// operator is Exists, the value should be empty, otherwise just
				// a regular string.
				value?: string
			}]
		}

		// Defines any existing volumes to reuse for this PostgresCluster.
		volumes?: {
			// Defines the existing pgBackRest repo volume and directory to
			// use in the current PostgresCluster.
			pgBackRestVolume?: {
				// The existing directory. When not set, a move Job is not created
				// for the associated volume.
				directory?: string

				// The existing PVC name.
				pvcName: string
			}

			// Defines the existing pgData volume and directory to use in the
			// current PostgresCluster.
			pgDataVolume?: {
				// The existing directory. When not set, a move Job is not created
				// for the associated volume.
				directory?: string

				// The existing PVC name.
				pvcName: string
			}

			// Defines the existing pg_wal volume and directory to use in the
			// current PostgresCluster. Note that a defined pg_wal volume
			// MUST be accompanied by a pgData volume.
			pgWALVolume?: {
				// The existing directory. When not set, a move Job is not created
				// for the associated volume.
				directory?: string

				// The existing PVC name.
				pvcName: string
			}
		}
	}

	// DatabaseInitSQL defines a ConfigMap containing custom SQL that
	// will be run after the cluster is initialized. This ConfigMap
	// must be in the same namespace as the cluster.
	databaseInitSQL?: {
		// Key is the ConfigMap data key that points to a SQL string
		key: string

		// Name is the name of a ConfigMap
		name: string
	}

	// Whether or not the PostgreSQL cluster should use the defined
	// default scheduling constraints. If the field is unset or
	// false, the default scheduling constraints will be used in
	// addition to any custom constraints provided.
	disableDefaultPodScheduling?: bool

	// The image name to use for PostgreSQL containers. When omitted,
	// the value comes from an operator environment variable. For
	// standard PostgreSQL images, the format is
	// RELATED_IMAGE_POSTGRES_{postgresVersion}, e.g.
	// RELATED_IMAGE_POSTGRES_13. For PostGIS enabled PostgreSQL
	// images, the format is
	// RELATED_IMAGE_POSTGRES_{postgresVersion}_GIS_{postGISVersion},
	// e.g. RELATED_IMAGE_POSTGRES_13_GIS_3.1.
	image?: string

	// ImagePullPolicy is used to determine when Kubernetes will
	// attempt to pull (download) container images. More info:
	// https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy
	imagePullPolicy?: "Always" | "Never" | "IfNotPresent"

	// The image pull secrets used to pull from a private registry
	// Changing this value causes all running pods to restart.
	// https://k8s.io/docs/tasks/configure-pod-container/pull-image-private-registry/
	imagePullSecrets?: [...{
		// Name of the referent. More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string
	}]

	// Specifies one or more sets of PostgreSQL pods that replicate
	// data for this cluster.
	instances: [...{
		// Scheduling constraints of a PostgreSQL pod. Changing this value
		// causes PostgreSQL to restart. More info:
		// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
		affinity?: {
			// Describes node affinity scheduling rules for the pod.
			nodeAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy the affinity expressions specified by this field, but
				// it may choose a node that violates one or more of the
				// expressions. The node that is most preferred is the one with
				// the greatest sum of weights, i.e. for each node that meets all
				// of the scheduling requirements (resource request,
				// requiredDuringScheduling affinity expressions, etc.), compute
				// a sum by iterating through the elements of this field and
				// adding "weight" to the sum if the node matches the
				// corresponding matchExpressions; the node(s) with the highest
				// sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// A node selector term, associated with the corresponding weight.
					preference: {
						// A list of node selector requirements by node's labels.
						matchExpressions?: [...{
							// The label key that the selector applies to.
							key: string

							// Represents a key's relationship to a set of values. Valid
							// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
							operator: string

							// An array of string values. If the operator is In or NotIn, the
							// values array must be non-empty. If the operator is Exists or
							// DoesNotExist, the values array must be empty. If the operator
							// is Gt or Lt, the values array must have a single element,
							// which will be interpreted as an integer. This array is
							// replaced during a strategic merge patch.
							values?: [...string]
						}]

						// A list of node selector requirements by node's fields.
						matchFields?: [...{
							// The label key that the selector applies to.
							key: string

							// Represents a key's relationship to a set of values. Valid
							// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
							operator: string

							// An array of string values. If the operator is In or NotIn, the
							// values array must be non-empty. If the operator is Exists or
							// DoesNotExist, the values array must be empty. If the operator
							// is Gt or Lt, the values array must have a single element,
							// which will be interpreted as an integer. This array is
							// replaced during a strategic merge patch.
							values?: [...string]
						}]
					}

					// Weight associated with matching the corresponding
					// nodeSelectorTerm, in the range 1-100.
					weight: int
				}]
				requiredDuringSchedulingIgnoredDuringExecution?: {
					// Required. A list of node selector terms. The terms are ORed.
					nodeSelectorTerms: [...{
						// A list of node selector requirements by node's labels.
						matchExpressions?: [...{
							// The label key that the selector applies to.
							key: string

							// Represents a key's relationship to a set of values. Valid
							// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
							operator: string

							// An array of string values. If the operator is In or NotIn, the
							// values array must be non-empty. If the operator is Exists or
							// DoesNotExist, the values array must be empty. If the operator
							// is Gt or Lt, the values array must have a single element,
							// which will be interpreted as an integer. This array is
							// replaced during a strategic merge patch.
							values?: [...string]
						}]

						// A list of node selector requirements by node's fields.
						matchFields?: [...{
							// The label key that the selector applies to.
							key: string

							// Represents a key's relationship to a set of values. Valid
							// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
							operator: string

							// An array of string values. If the operator is In or NotIn, the
							// values array must be non-empty. If the operator is Exists or
							// DoesNotExist, the values array must be empty. If the operator
							// is Gt or Lt, the values array must have a single element,
							// which will be interpreted as an integer. This array is
							// replaced during a strategic merge patch.
							values?: [...string]
						}]
					}]
				}
			}

			// Describes pod affinity scheduling rules (e.g. co-locate this
			// pod in the same node, zone, etc. as some other pod(s)).
			podAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy the affinity expressions specified by this field, but
				// it may choose a node that violates one or more of the
				// expressions. The node that is most preferred is the one with
				// the greatest sum of weights, i.e. for each node that meets all
				// of the scheduling requirements (resource request,
				// requiredDuringScheduling affinity expressions, etc.), compute
				// a sum by iterating through the elements of this field and
				// adding "weight" to the sum if the node has pods which matches
				// the corresponding podAffinityTerm; the node(s) with the
				// highest sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// Required. A pod affinity term, associated with the
					// corresponding weight.
					podAffinityTerm: {
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}

					// weight associated with matching the corresponding
					// podAffinityTerm, in the range 1-100.
					weight: int
				}]

				// If the affinity requirements specified by this field are not
				// met at scheduling time, the pod will not be scheduled onto the
				// node. If the affinity requirements specified by this field
				// cease to be met at some point during pod execution (e.g. due
				// to a pod label update), the system may or may not try to
				// eventually evict the pod from its node. When there are
				// multiple elements, the lists of nodes corresponding to each
				// podAffinityTerm are intersected, i.e. all terms must be
				// satisfied.
				requiredDuringSchedulingIgnoredDuringExecution?: [...{
					// A label query over a set of resources, in this case pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// A label query over the set of namespaces that the term applies
					// to. The term is applied to the union of the namespaces
					// selected by this field and the ones listed in the namespaces
					// field. null selector and null or empty namespaces list means
					// "this pod's namespace". An empty selector ({}) matches all
					// namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to. The term is applied to the union of the
					// namespaces listed in this field and the ones selected by
					// namespaceSelector. null or empty namespaces list and null
					// namespaceSelector means "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching the labelSelector in
					// the specified namespaces, where co-located is defined as
					// running on a node whose value of the label with key
					// topologyKey matches that of any node on which any of the
					// selected pods is running. Empty topologyKey is not allowed.
					topologyKey: string
				}]
			}

			// Describes pod anti-affinity scheduling rules (e.g. avoid
			// putting this pod in the same node, zone, etc. as some other
			// pod(s)).
			podAntiAffinity?: {
				// The scheduler will prefer to schedule pods to nodes that
				// satisfy the anti-affinity expressions specified by this field,
				// but it may choose a node that violates one or more of the
				// expressions. The node that is most preferred is the one with
				// the greatest sum of weights, i.e. for each node that meets all
				// of the scheduling requirements (resource request,
				// requiredDuringScheduling anti-affinity expressions, etc.),
				// compute a sum by iterating through the elements of this field
				// and adding "weight" to the sum if the node has pods which
				// matches the corresponding podAffinityTerm; the node(s) with
				// the highest sum are the most preferred.
				preferredDuringSchedulingIgnoredDuringExecution?: [...{
					// Required. A pod affinity term, associated with the
					// corresponding weight.
					podAffinityTerm: {
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}

					// weight associated with matching the corresponding
					// podAffinityTerm, in the range 1-100.
					weight: int
				}]

				// If the anti-affinity requirements specified by this field are
				// not met at scheduling time, the pod will not be scheduled onto
				// the node. If the anti-affinity requirements specified by this
				// field cease to be met at some point during pod execution (e.g.
				// due to a pod label update), the system may or may not try to
				// eventually evict the pod from its node. When there are
				// multiple elements, the lists of nodes corresponding to each
				// podAffinityTerm are intersected, i.e. all terms must be
				// satisfied.
				requiredDuringSchedulingIgnoredDuringExecution?: [...{
					// A label query over a set of resources, in this case pods.
					labelSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// A label query over the set of namespaces that the term applies
					// to. The term is applied to the union of the namespaces
					// selected by this field and the ones listed in the namespaces
					// field. null selector and null or empty namespaces list means
					// "this pod's namespace". An empty selector ({}) matches all
					// namespaces.
					namespaceSelector?: {
						// matchExpressions is a list of label selector requirements. The
						// requirements are ANDed.
						matchExpressions?: [...{
							// key is the label key that the selector applies to.
							key: string

							// operator represents a key's relationship to a set of values.
							// Valid operators are In, NotIn, Exists and DoesNotExist.
							operator: string

							// values is an array of string values. If the operator is In or
							// NotIn, the values array must be non-empty. If the operator is
							// Exists or DoesNotExist, the values array must be empty. This
							// array is replaced during a strategic merge patch.
							values?: [...string]
						}]

						// matchLabels is a map of {key,value} pairs. A single {key,value}
						// in the matchLabels map is equivalent to an element of
						// matchExpressions, whose key field is "key", the operator is
						// "In", and the values array contains only "value". The
						// requirements are ANDed.
						matchLabels?: {
							[string]: string
						}
					}

					// namespaces specifies a static list of namespace names that the
					// term applies to. The term is applied to the union of the
					// namespaces listed in this field and the ones selected by
					// namespaceSelector. null or empty namespaces list and null
					// namespaceSelector means "this pod's namespace".
					namespaces?: [...string]

					// This pod should be co-located (affinity) or not co-located
					// (anti-affinity) with the pods matching the labelSelector in
					// the specified namespaces, where co-located is defined as
					// running on a node whose value of the label with key
					// topologyKey matches that of any node on which any of the
					// selected pods is running. Empty topologyKey is not allowed.
					topologyKey: string
				}]
			}
		}

		// Custom sidecars for PostgreSQL instance pods. Changing this
		// value causes PostgreSQL to restart.
		containers?: [...{
			// Arguments to the entrypoint. The container image's CMD is used
			// if this is not provided. Variable references $(VAR_NAME) are
			// expanded using the container's environment. If a variable
			// cannot be resolved, the reference in the input string will be
			// unchanged. Double $$ are reduced to a single $, which allows
			// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
			// produce the string literal "$(VAR_NAME)". Escaped references
			// will never be expanded, regardless of whether the variable
			// exists or not. Cannot be updated. More info:
			// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			args?: [...string]

			// Entrypoint array. Not executed within a shell. The container
			// image's ENTRYPOINT is used if this is not provided. Variable
			// references $(VAR_NAME) are expanded using the container's
			// environment. If a variable cannot be resolved, the reference
			// in the input string will be unchanged. Double $$ are reduced
			// to a single $, which allows for escaping the $(VAR_NAME)
			// syntax: i.e. "$$(VAR_NAME)" will produce the string literal
			// "$(VAR_NAME)". Escaped references will never be expanded,
			// regardless of whether the variable exists or not. Cannot be
			// updated. More info:
			// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
			command?: [...string]

			// List of environment variables to set in the container. Cannot
			// be updated.
			env?: [...{
				// Name of the environment variable. Must be a C_IDENTIFIER.
				name: string

				// Variable references $(VAR_NAME) are expanded using the
				// previously defined environment variables in the container and
				// any service environment variables. If a variable cannot be
				// resolved, the reference in the input string will be unchanged.
				// Double $$ are reduced to a single $, which allows for escaping
				// the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the
				// string literal "$(VAR_NAME)". Escaped references will never be
				// expanded, regardless of whether the variable exists or not.
				// Defaults to "".
				value?: string

				// Source for the environment variable's value. Cannot be used if
				// value is not empty.
				valueFrom?: {
					// Selects a key of a ConfigMap.
					configMapKeyRef?: {
						// The key to select.
						key: string

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the ConfigMap or its key must be defined
						optional?: bool
					}

					// Selects a field of the pod: supports metadata.name,
					// metadata.namespace, `metadata.labels['<KEY>']`,
					// `metadata.annotations['<KEY>']`, spec.nodeName,
					// spec.serviceAccountName, status.hostIP, status.podIP,
					// status.podIPs.
					fieldRef?: {
						// Version of the schema the FieldPath is written in terms of,
						// defaults to "v1".
						apiVersion?: string

						// Path of the field to select in the specified API version.
						fieldPath: string
					}

					// Selects a resource of the container: only resources limits and
					// requests (limits.cpu, limits.memory, limits.ephemeral-storage,
					// requests.cpu, requests.memory and requests.ephemeral-storage)
					// are currently supported.
					resourceFieldRef?: {
						// Container name: required for volumes, optional for env vars
						containerName?: string

						// Specifies the output format of the exposed resources, defaults
						// to "1"
						divisor?: (int | string) & {
							=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Required: resource to select
						resource: string
					}

					// Selects a key of a secret in the pod's namespace
					secretKeyRef?: {
						// The key of the secret to select from. Must be a valid secret
						// key.
						key: string

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the Secret or its key must be defined
						optional?: bool
					}
				}
			}]

			// List of sources to populate environment variables in the
			// container. The keys defined within a source must be a
			// C_IDENTIFIER. All invalid keys will be reported as an event
			// when the container is starting. When a key exists in multiple
			// sources, the value associated with the last source will take
			// precedence. Values defined by an Env with a duplicate key will
			// take precedence. Cannot be updated.
			envFrom?: [...{
				// The ConfigMap to select from
				configMapRef?: {
					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap must be defined
					optional?: bool
				}

				// An optional identifier to prepend to each key in the ConfigMap.
				// Must be a C_IDENTIFIER.
				prefix?: string

				// The Secret to select from
				secretRef?: {
					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret must be defined
					optional?: bool
				}
			}]

			// Container image name. More info:
			// https://kubernetes.io/docs/concepts/containers/images This
			// field is optional to allow higher level config management to
			// default or override container images in workload controllers
			// like Deployments and StatefulSets.
			image?: string

			// Image pull policy. One of Always, Never, IfNotPresent. Defaults
			// to Always if :latest tag is specified, or IfNotPresent
			// otherwise. Cannot be updated. More info:
			// https://kubernetes.io/docs/concepts/containers/images#updating-images
			imagePullPolicy?: string

			// Actions that the management system should take in response to
			// container lifecycle events. Cannot be updated.
			lifecycle?: {
				// PostStart is called immediately after a container is created.
				// If the handler fails, the container is terminated and
				// restarted according to its restart policy. Other management of
				// the container blocks until the hook completes. More info:
				// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
				postStart?: {
					exec?: {
						// Command is the command line to execute inside the container,
						// the working directory for the command is root ('/') in the
						// container's filesystem. The command is simply exec'd, it is
						// not run inside a shell, so traditional shell instructions
						// ('|', etc) won't work. To use a shell, you need to explicitly
						// call out to that shell. Exit status of 0 is treated as
						// live/healthy and non-zero is unhealthy.
						command?: [...string]
					}

					// HTTPGet specifies the http request to perform.
					httpGet?: {
						// Host name to connect to, defaults to the pod IP. You probably
						// want to set "Host" in httpHeaders instead.
						host?: string

						// Custom headers to set in the request. HTTP allows repeated
						// headers.
						httpHeaders?: [...{
							// The header field name
							name: string

							// The header field value
							value: string
						}]

						// Path to access on the HTTP server.
						path?: string

						// Name or number of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}

						// Scheme to use for connecting to the host. Defaults to HTTP.
						scheme?: string
					}

					// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
					// and kept for the backward compatibility. There are no
					// validation of this field and lifecycle hooks will fail in
					// runtime when tcp handler is specified.
					tcpSocket?: {
						// Optional: Host name to connect to, defaults to the pod IP.
						host?: string

						// Number or name of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}
					}
				}

				// PreStop is called immediately before a container is terminated
				// due to an API request or management event such as
				// liveness/startup probe failure, preemption, resource
				// contention, etc. The handler is not called if the container
				// crashes or exits. The Pod's termination grace period countdown
				// begins before the PreStop hook is executed. Regardless of the
				// outcome of the handler, the container will eventually
				// terminate within the Pod's termination grace period (unless
				// delayed by finalizers). Other management of the container
				// blocks until the hook completes or until the termination grace
				// period is reached. More info:
				// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
				preStop?: {
					exec?: {
						// Command is the command line to execute inside the container,
						// the working directory for the command is root ('/') in the
						// container's filesystem. The command is simply exec'd, it is
						// not run inside a shell, so traditional shell instructions
						// ('|', etc) won't work. To use a shell, you need to explicitly
						// call out to that shell. Exit status of 0 is treated as
						// live/healthy and non-zero is unhealthy.
						command?: [...string]
					}

					// HTTPGet specifies the http request to perform.
					httpGet?: {
						// Host name to connect to, defaults to the pod IP. You probably
						// want to set "Host" in httpHeaders instead.
						host?: string

						// Custom headers to set in the request. HTTP allows repeated
						// headers.
						httpHeaders?: [...{
							// The header field name
							name: string

							// The header field value
							value: string
						}]

						// Path to access on the HTTP server.
						path?: string

						// Name or number of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}

						// Scheme to use for connecting to the host. Defaults to HTTP.
						scheme?: string
					}

					// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
					// and kept for the backward compatibility. There are no
					// validation of this field and lifecycle hooks will fail in
					// runtime when tcp handler is specified.
					tcpSocket?: {
						// Optional: Host name to connect to, defaults to the pod IP.
						host?: string

						// Number or name of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}
					}
				}
			}

			// Periodic probe of container liveness. Container will be
			// restarted if the probe fails. Cannot be updated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			livenessProbe?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: int

				// GRPC specifies an action involving a GRPC port. This is a beta
				// field and requires enabling GRPCContainerProbe feature gate.
				grpc?: {
					// Port number of the gRPC service. Number must be in the range 1
					// to 65535.
					port: int

					// Service is the name of the service to place in the gRPC
					// HealthCheckRequest (see
					// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
					// If this is not specified, the default behavior is defined by
					// gRPC.
					service?: string
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}

				// Number of seconds after the container has started before
				// liveness probes are initiated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				initialDelaySeconds?: int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness and startup. Minimum value is 1.
				successThreshold?: int

				// TCPSocket specifies an action involving a TCP port.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}

				// Optional duration in seconds the pod needs to terminate
				// gracefully upon probe failure. The grace period is the
				// duration in seconds after the processes running in the pod are
				// sent a termination signal and the time when the processes are
				// forcibly halted with a kill signal. Set this value longer than
				// the expected cleanup time for your process. If this value is
				// nil, the pod's terminationGracePeriodSeconds will be used.
				// Otherwise, this value overrides the value provided by the pod
				// spec. Value must be non-negative integer. The value zero
				// indicates stop immediately via the kill signal (no opportunity
				// to shut down). This is a beta field and requires enabling
				// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
				// spec.terminationGracePeriodSeconds is used if unset.
				terminationGracePeriodSeconds?: int

				// Number of seconds after which the probe times out. Defaults to
				// 1 second. Minimum value is 1. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				timeoutSeconds?: int
			}

			// Name of the container specified as a DNS_LABEL. Each container
			// in a pod must have a unique name (DNS_LABEL). Cannot be
			// updated.
			name: string

			// List of ports to expose from the container. Exposing a port
			// here gives the system additional information about the network
			// connections a container uses, but is primarily informational.
			// Not specifying a port here DOES NOT prevent that port from
			// being exposed. Any port which is listening on the default
			// "0.0.0.0" address inside a container will be accessible from
			// the network. Cannot be updated.
			ports?: [...{
				// Number of port to expose on the pod's IP address. This must be
				// a valid port number, 0 < x < 65536.
				containerPort: int

				// What host IP to bind the external port to.
				hostIP?: string

				// Number of port to expose on the host. If specified, this must
				// be a valid port number, 0 < x < 65536. If HostNetwork is
				// specified, this must match ContainerPort. Most containers do
				// not need this.
				hostPort?: int

				// If specified, this must be an IANA_SVC_NAME and unique within
				// the pod. Each named port in a pod must have a unique name.
				// Name for the port that can be referred to by services.
				name?: string

				// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to
				// "TCP".
				protocol?: string | *"TCP"
			}]

			// Periodic probe of container service readiness. Container will
			// be removed from service endpoints if the probe fails. Cannot
			// be updated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			readinessProbe?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: int

				// GRPC specifies an action involving a GRPC port. This is a beta
				// field and requires enabling GRPCContainerProbe feature gate.
				grpc?: {
					// Port number of the gRPC service. Number must be in the range 1
					// to 65535.
					port: int

					// Service is the name of the service to place in the gRPC
					// HealthCheckRequest (see
					// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
					// If this is not specified, the default behavior is defined by
					// gRPC.
					service?: string
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}

				// Number of seconds after the container has started before
				// liveness probes are initiated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				initialDelaySeconds?: int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness and startup. Minimum value is 1.
				successThreshold?: int

				// TCPSocket specifies an action involving a TCP port.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}

				// Optional duration in seconds the pod needs to terminate
				// gracefully upon probe failure. The grace period is the
				// duration in seconds after the processes running in the pod are
				// sent a termination signal and the time when the processes are
				// forcibly halted with a kill signal. Set this value longer than
				// the expected cleanup time for your process. If this value is
				// nil, the pod's terminationGracePeriodSeconds will be used.
				// Otherwise, this value overrides the value provided by the pod
				// spec. Value must be non-negative integer. The value zero
				// indicates stop immediately via the kill signal (no opportunity
				// to shut down). This is a beta field and requires enabling
				// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
				// spec.terminationGracePeriodSeconds is used if unset.
				terminationGracePeriodSeconds?: int

				// Number of seconds after which the probe times out. Defaults to
				// 1 second. Minimum value is 1. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				timeoutSeconds?: int
			}

			// Compute Resources required by this container. Cannot be
			// updated. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			resources?: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// SecurityContext defines the security options the container
			// should be run with. If set, the fields of SecurityContext
			// override the equivalent fields of PodSecurityContext. More
			// info:
			// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
			securityContext?: {
				// AllowPrivilegeEscalation controls whether a process can gain
				// more privileges than its parent process. This bool directly
				// controls if the no_new_privs flag will be set on the container
				// process. AllowPrivilegeEscalation is true always when the
				// container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note
				// that this field cannot be set when spec.os.name is windows.
				allowPrivilegeEscalation?: bool

				// The capabilities to add/drop when running containers. Defaults
				// to the default set of capabilities granted by the container
				// runtime. Note that this field cannot be set when spec.os.name
				// is windows.
				capabilities?: {
					// Added capabilities
					add?: [...string]

					// Removed capabilities
					drop?: [...string]
				}

				// Run container in privileged mode. Processes in privileged
				// containers are essentially equivalent to root on the host.
				// Defaults to false. Note that this field cannot be set when
				// spec.os.name is windows.
				privileged?: bool

				// procMount denotes the type of proc mount to use for the
				// containers. The default is DefaultProcMount which uses the
				// container runtime defaults for readonly paths and masked
				// paths. This requires the ProcMountType feature flag to be
				// enabled. Note that this field cannot be set when spec.os.name
				// is windows.
				procMount?: string

				// Whether this container has a read-only root filesystem. Default
				// is false. Note that this field cannot be set when spec.os.name
				// is windows.
				readOnlyRootFilesystem?: bool

				// The GID to run the entrypoint of the container process. Uses
				// runtime default if unset. May also be set in
				// PodSecurityContext. If set in both SecurityContext and
				// PodSecurityContext, the value specified in SecurityContext
				// takes precedence. Note that this field cannot be set when
				// spec.os.name is windows.
				runAsGroup?: int

				// Indicates that the container must run as a non-root user. If
				// true, the Kubelet will validate the image at runtime to ensure
				// that it does not run as UID 0 (root) and fail to start the
				// container if it does. If unset or false, no such validation
				// will be performed. May also be set in PodSecurityContext. If
				// set in both SecurityContext and PodSecurityContext, the value
				// specified in SecurityContext takes precedence.
				runAsNonRoot?: bool

				// The UID to run the entrypoint of the container process.
				// Defaults to user specified in image metadata if unspecified.
				// May also be set in PodSecurityContext. If set in both
				// SecurityContext and PodSecurityContext, the value specified in
				// SecurityContext takes precedence. Note that this field cannot
				// be set when spec.os.name is windows.
				runAsUser?: int

				// The SELinux context to be applied to the container. If
				// unspecified, the container runtime will allocate a random
				// SELinux context for each container. May also be set in
				// PodSecurityContext. If set in both SecurityContext and
				// PodSecurityContext, the value specified in SecurityContext
				// takes precedence. Note that this field cannot be set when
				// spec.os.name is windows.
				seLinuxOptions?: {
					// Level is SELinux level label that applies to the container.
					level?: string

					// Role is a SELinux role label that applies to the container.
					role?: string

					// Type is a SELinux type label that applies to the container.
					type?: string

					// User is a SELinux user label that applies to the container.
					user?: string
				}

				// The seccomp options to use by this container. If seccomp
				// options are provided at both the pod & container level, the
				// container options override the pod options. Note that this
				// field cannot be set when spec.os.name is windows.
				seccompProfile?: {
					// localhostProfile indicates a profile defined in a file on the
					// node should be used. The profile must be preconfigured on the
					// node to work. Must be a descending path, relative to the
					// kubelet's configured seccomp profile location. Must only be
					// set if type is "Localhost".
					localhostProfile?: string

					// type indicates which kind of seccomp profile will be applied.
					// Valid options are: Localhost - a profile defined in a file on
					// the node should be used. RuntimeDefault - the container
					// runtime default profile should be used. Unconfined - no
					// profile should be applied.
					type: string
				}

				// The Windows specific settings applied to all containers. If
				// unspecified, the options from the PodSecurityContext will be
				// used. If set in both SecurityContext and PodSecurityContext,
				// the value specified in SecurityContext takes precedence. Note
				// that this field cannot be set when spec.os.name is linux.
				windowsOptions?: {
					// GMSACredentialSpec is where the GMSA admission webhook
					// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
					// contents of the GMSA credential spec named by the
					// GMSACredentialSpecName field.
					gmsaCredentialSpec?: string

					// GMSACredentialSpecName is the name of the GMSA credential spec
					// to use.
					gmsaCredentialSpecName?: string

					// HostProcess determines if a container should be run as a 'Host
					// Process' container. This field is alpha-level and will only be
					// honored by components that enable the
					// WindowsHostProcessContainers feature flag. Setting this field
					// without the feature flag will result in errors when validating
					// the Pod. All of a Pod's containers must have the same
					// effective HostProcess value (it is not allowed to have a mix
					// of HostProcess containers and non-HostProcess containers). In
					// addition, if HostProcess is true then HostNetwork must also be
					// set to true.
					hostProcess?: bool

					// The UserName in Windows to run the entrypoint of the container
					// process. Defaults to the user specified in image metadata if
					// unspecified. May also be set in PodSecurityContext. If set in
					// both SecurityContext and PodSecurityContext, the value
					// specified in SecurityContext takes precedence.
					runAsUserName?: string
				}
			}

			// StartupProbe indicates that the Pod has successfully
			// initialized. If specified, no other probes are executed until
			// this completes successfully. If this probe fails, the Pod will
			// be restarted, just as if the livenessProbe failed. This can be
			// used to provide different probe parameters at the beginning of
			// a Pod's lifecycle, when it might take a long time to load data
			// or warm a cache, than during steady-state operation. This
			// cannot be updated. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
			startupProbe?: {
				exec?: {
					// Command is the command line to execute inside the container,
					// the working directory for the command is root ('/') in the
					// container's filesystem. The command is simply exec'd, it is
					// not run inside a shell, so traditional shell instructions
					// ('|', etc) won't work. To use a shell, you need to explicitly
					// call out to that shell. Exit status of 0 is treated as
					// live/healthy and non-zero is unhealthy.
					command?: [...string]
				}

				// Minimum consecutive failures for the probe to be considered
				// failed after having succeeded. Defaults to 3. Minimum value is
				// 1.
				failureThreshold?: int

				// GRPC specifies an action involving a GRPC port. This is a beta
				// field and requires enabling GRPCContainerProbe feature gate.
				grpc?: {
					// Port number of the gRPC service. Number must be in the range 1
					// to 65535.
					port: int

					// Service is the name of the service to place in the gRPC
					// HealthCheckRequest (see
					// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
					// If this is not specified, the default behavior is defined by
					// gRPC.
					service?: string
				}

				// HTTPGet specifies the http request to perform.
				httpGet?: {
					// Host name to connect to, defaults to the pod IP. You probably
					// want to set "Host" in httpHeaders instead.
					host?: string

					// Custom headers to set in the request. HTTP allows repeated
					// headers.
					httpHeaders?: [...{
						// The header field name
						name: string

						// The header field value
						value: string
					}]

					// Path to access on the HTTP server.
					path?: string

					// Name or number of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}

					// Scheme to use for connecting to the host. Defaults to HTTP.
					scheme?: string
				}

				// Number of seconds after the container has started before
				// liveness probes are initiated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				initialDelaySeconds?: int

				// How often (in seconds) to perform the probe. Default to 10
				// seconds. Minimum value is 1.
				periodSeconds?: int

				// Minimum consecutive successes for the probe to be considered
				// successful after having failed. Defaults to 1. Must be 1 for
				// liveness and startup. Minimum value is 1.
				successThreshold?: int

				// TCPSocket specifies an action involving a TCP port.
				tcpSocket?: {
					// Optional: Host name to connect to, defaults to the pod IP.
					host?: string

					// Number or name of the port to access on the container. Number
					// must be in the range 1 to 65535. Name must be an
					// IANA_SVC_NAME.
					port: (int | string) & {
						string
					}
				}

				// Optional duration in seconds the pod needs to terminate
				// gracefully upon probe failure. The grace period is the
				// duration in seconds after the processes running in the pod are
				// sent a termination signal and the time when the processes are
				// forcibly halted with a kill signal. Set this value longer than
				// the expected cleanup time for your process. If this value is
				// nil, the pod's terminationGracePeriodSeconds will be used.
				// Otherwise, this value overrides the value provided by the pod
				// spec. Value must be non-negative integer. The value zero
				// indicates stop immediately via the kill signal (no opportunity
				// to shut down). This is a beta field and requires enabling
				// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
				// spec.terminationGracePeriodSeconds is used if unset.
				terminationGracePeriodSeconds?: int

				// Number of seconds after which the probe times out. Defaults to
				// 1 second. Minimum value is 1. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				timeoutSeconds?: int
			}

			// Whether this container should allocate a buffer for stdin in
			// the container runtime. If this is not set, reads from stdin in
			// the container will always result in EOF. Default is false.
			stdin?: bool

			// Whether the container runtime should close the stdin channel
			// after it has been opened by a single attach. When stdin is
			// true the stdin stream will remain open across multiple attach
			// sessions. If stdinOnce is set to true, stdin is opened on
			// container start, is empty until the first client attaches to
			// stdin, and then remains open and accepts data until the client
			// disconnects, at which time stdin is closed and remains closed
			// until the container is restarted. If this flag is false, a
			// container processes that reads from stdin will never receive
			// an EOF. Default is false
			stdinOnce?: bool

			// Optional: Path at which the file to which the container's
			// termination message will be written is mounted into the
			// container's filesystem. Message written is intended to be
			// brief final status, such as an assertion failure message. Will
			// be truncated by the node if greater than 4096 bytes. The total
			// message length across all containers will be limited to 12kb.
			// Defaults to /dev/termination-log. Cannot be updated.
			terminationMessagePath?: string

			// Indicate how the termination message should be populated. File
			// will use the contents of terminationMessagePath to populate
			// the container status message on both success and failure.
			// FallbackToLogsOnError will use the last chunk of container log
			// output if the termination message file is empty and the
			// container exited with an error. The log output is limited to
			// 2048 bytes or 80 lines, whichever is smaller. Defaults to
			// File. Cannot be updated.
			terminationMessagePolicy?: string

			// Whether this container should allocate a TTY for itself, also
			// requires 'stdin' to be true. Default is false.
			tty?: bool

			// volumeDevices is the list of block devices to be used by the
			// container.
			volumeDevices?: [...{
				// devicePath is the path inside of the container that the device
				// will be mapped to.
				devicePath: string

				// name must match the name of a persistentVolumeClaim in the pod
				name: string
			}]

			// Pod volumes to mount into the container's filesystem. Cannot be
			// updated.
			volumeMounts?: [...{
				// Path within the container at which the volume should be
				// mounted. Must not contain ':'.
				mountPath: string

				// mountPropagation determines how mounts are propagated from the
				// host to container and the other way around. When not set,
				// MountPropagationNone is used. This field is beta in 1.10.
				mountPropagation?: string

				// This must match the Name of a Volume.
				name: string

				// Mounted read-only if true, read-write otherwise (false or
				// unspecified). Defaults to false.
				readOnly?: bool

				// Path within the volume from which the container's volume should
				// be mounted. Defaults to "" (volume's root).
				subPath?: string

				// Expanded path within the volume from which the container's
				// volume should be mounted. Behaves similarly to SubPath but
				// environment variable references $(VAR_NAME) are expanded using
				// the container's environment. Defaults to "" (volume's root).
				// SubPathExpr and SubPath are mutually exclusive.
				subPathExpr?: string
			}]

			// Container's working directory. If not specified, the container
			// runtime's default will be used, which might be configured in
			// the container image. Cannot be updated.
			workingDir?: string
		}]

		// Defines a PersistentVolumeClaim for PostgreSQL data. More info:
		// https://kubernetes.io/docs/concepts/storage/persistent-volumes
		dataVolumeClaimSpec: {
			// accessModes contains the desired access modes the volume should
			// have. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
			accessModes: [...string] & [_, ...]

			// dataSource field can be used to specify either: * An existing
			// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
			// * An existing PVC (PersistentVolumeClaim) If the provisioner
			// or an external controller can support the specified data
			// source, it will create a new volume based on the contents of
			// the specified data source. If the AnyVolumeDataSource feature
			// gate is enabled, this field will always have the same contents
			// as the DataSourceRef field.
			dataSource?: {
				// APIGroup is the group for the resource being referenced. If
				// APIGroup is not specified, the specified Kind must be in the
				// core API group. For any other third-party types, APIGroup is
				// required.
				apiGroup?: string

				// Kind is the type of resource being referenced
				kind: string

				// Name is the name of resource being referenced
				name: string
			}

			// dataSourceRef specifies the object from which to populate the
			// volume with data, if a non-empty volume is desired. This may
			// be any local object from a non-empty API group (non core
			// object) or a PersistentVolumeClaim object. When this field is
			// specified, volume binding will only succeed if the type of the
			// specified object matches some installed volume populator or
			// dynamic provisioner. This field will replace the functionality
			// of the DataSource field and as such if both fields are
			// non-empty, they must have the same value. For backwards
			// compatibility, both fields (DataSource and DataSourceRef) will
			// be set to the same value automatically if one of them is empty
			// and the other is non-empty. There are two important
			// differences between DataSource and DataSourceRef: * While
			// DataSource only allows two specific types of objects,
			// DataSourceRef allows any non-core object, as well as
			// PersistentVolumeClaim objects. * While DataSource ignores
			// disallowed values (dropping them), DataSourceRef preserves all
			// values, and generates an error if a disallowed value is
			// specified. (Beta) Using this field requires the
			// AnyVolumeDataSource feature gate to be enabled.
			dataSourceRef?: {
				// APIGroup is the group for the resource being referenced. If
				// APIGroup is not specified, the specified Kind must be in the
				// core API group. For any other third-party types, APIGroup is
				// required.
				apiGroup?: string

				// Kind is the type of resource being referenced
				kind: string

				// Name is the name of resource being referenced
				name: string
			}

			// resources represents the minimum resources the volume should
			// have. If RecoverVolumeExpansionFailure feature is enabled
			// users are allowed to specify resource requirements that are
			// lower than previous value but must still be higher than
			// capacity recorded in the status field of the claim. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
			resources: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests: {
					{
						[!~"^(storage)$"]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
					storage: _
				}
			}

			// selector is a label query over volumes to consider for binding.
			selector?: {
				// matchExpressions is a list of label selector requirements. The
				// requirements are ANDed.
				matchExpressions?: [...{
					// key is the label key that the selector applies to.
					key: string

					// operator represents a key's relationship to a set of values.
					// Valid operators are In, NotIn, Exists and DoesNotExist.
					operator: string

					// values is an array of string values. If the operator is In or
					// NotIn, the values array must be non-empty. If the operator is
					// Exists or DoesNotExist, the values array must be empty. This
					// array is replaced during a strategic merge patch.
					values?: [...string]
				}]

				// matchLabels is a map of {key,value} pairs. A single {key,value}
				// in the matchLabels map is equivalent to an element of
				// matchExpressions, whose key field is "key", the operator is
				// "In", and the values array contains only "value". The
				// requirements are ANDed.
				matchLabels?: {
					[string]: string
				}
			}

			// storageClassName is the name of the StorageClass required by
			// the claim. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
			storageClassName?: string

			// volumeMode defines what type of volume is required by the
			// claim. Value of Filesystem is implied when not included in
			// claim spec.
			volumeMode?: string

			// volumeName is the binding reference to the PersistentVolume
			// backing this claim.
			volumeName?: string
		}

		// Metadata contains metadata for custom resources
		metadata?: {
			annotations?: {
				[string]: string
			}
			labels?: {
				[string]: string
			}
		}

		// Minimum number of pods that should be available at a time.
		// Defaults to one when the replicas field is greater than one.
		minAvailable?: (int | string) & {
			string
		}

		// Name that associates this set of PostgreSQL pods. This field is
		// optional when only one instance set is defined. Each instance
		// set in a cluster must have a unique name. The combined length
		// of this and the cluster name must be 46 characters or less.
		name?: =~"^([a-z0-9]([-a-z0-9]*[a-z0-9])?)?$" | *""

		// Priority class name for the PostgreSQL pod. Changing this value
		// causes PostgreSQL to restart. More info:
		// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
		priorityClassName?: string

		// Number of desired PostgreSQL pods.
		replicas?: int & >=1 | *1

		// Compute resources of a PostgreSQL container.
		resources?: {
			// Limits describes the maximum amount of compute resources
			// allowed. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			limits?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}

			// Requests describes the minimum amount of compute resources
			// required. If Requests is omitted for a container, it defaults
			// to Limits if that is explicitly specified, otherwise to an
			// implementation-defined value. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
			requests?: {
				[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
			}
		}
		sidecars?: {
			replicaCertCopy?: {
				// Resource requirements for a sidecar container
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}
			}
		}

		// The list of tablespaces volumes to mount for this
		// postgrescluster This field requires enabling TablespaceVolumes
		// feature gate
		tablespaceVolumes?: [...{
			// Defines a PersistentVolumeClaim for a tablespace. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes
			dataVolumeClaimSpec: {
				// accessModes contains the desired access modes the volume should
				// have. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
				accessModes?: [...string]

				// dataSource field can be used to specify either: * An existing
				// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
				// * An existing PVC (PersistentVolumeClaim) If the provisioner
				// or an external controller can support the specified data
				// source, it will create a new volume based on the contents of
				// the specified data source. If the AnyVolumeDataSource feature
				// gate is enabled, this field will always have the same contents
				// as the DataSourceRef field.
				dataSource?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// dataSourceRef specifies the object from which to populate the
				// volume with data, if a non-empty volume is desired. This may
				// be any local object from a non-empty API group (non core
				// object) or a PersistentVolumeClaim object. When this field is
				// specified, volume binding will only succeed if the type of the
				// specified object matches some installed volume populator or
				// dynamic provisioner. This field will replace the functionality
				// of the DataSource field and as such if both fields are
				// non-empty, they must have the same value. For backwards
				// compatibility, both fields (DataSource and DataSourceRef) will
				// be set to the same value automatically if one of them is empty
				// and the other is non-empty. There are two important
				// differences between DataSource and DataSourceRef: * While
				// DataSource only allows two specific types of objects,
				// DataSourceRef allows any non-core object, as well as
				// PersistentVolumeClaim objects. * While DataSource ignores
				// disallowed values (dropping them), DataSourceRef preserves all
				// values, and generates an error if a disallowed value is
				// specified. (Beta) Using this field requires the
				// AnyVolumeDataSource feature gate to be enabled.
				dataSourceRef?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// resources represents the minimum resources the volume should
				// have. If RecoverVolumeExpansionFailure feature is enabled
				// users are allowed to specify resource requirements that are
				// lower than previous value but must still be higher than
				// capacity recorded in the status field of the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// selector is a label query over volumes to consider for binding.
				selector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// storageClassName is the name of the StorageClass required by
				// the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
				storageClassName?: string

				// volumeMode defines what type of volume is required by the
				// claim. Value of Filesystem is implied when not included in
				// claim spec.
				volumeMode?: string

				// volumeName is the binding reference to the PersistentVolume
				// backing this claim.
				volumeName?: string
			}

			// The name for the tablespace, used as the path name for the
			// volume. Must be unique in the instance set since they become
			// the directory names.
			name: strings.MinRunes(1) & {
				=~"^[a-z][a-z0-9]*$"
			}
		}]

		// Tolerations of a PostgreSQL pod. Changing this value causes
		// PostgreSQL to restart. More info:
		// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
		tolerations?: [...{
			// Effect indicates the taint effect to match. Empty means match
			// all taint effects. When specified, allowed values are
			// NoSchedule, PreferNoSchedule and NoExecute.
			effect?: string

			// Key is the taint key that the toleration applies to. Empty
			// means match all taint keys. If the key is empty, operator must
			// be Exists; this combination means to match all values and all
			// keys.
			key?: string

			// Operator represents a key's relationship to the value. Valid
			// operators are Exists and Equal. Defaults to Equal. Exists is
			// equivalent to wildcard for value, so that a pod can tolerate
			// all taints of a particular category.
			operator?: string

			// TolerationSeconds represents the period of time the toleration
			// (which must be of effect NoExecute, otherwise this field is
			// ignored) tolerates the taint. By default, it is not set, which
			// means tolerate the taint forever (do not evict). Zero and
			// negative values will be treated as 0 (evict immediately) by
			// the system.
			tolerationSeconds?: int

			// Value is the taint value the toleration matches to. If the
			// operator is Exists, the value should be empty, otherwise just
			// a regular string.
			value?: string
		}]

		// Topology spread constraints of a PostgreSQL pod. Changing this
		// value causes PostgreSQL to restart. More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
		topologySpreadConstraints?: [...{
			// LabelSelector is used to find matching pods. Pods that match
			// this label selector are counted to determine the number of
			// pods in their corresponding topology domain.
			labelSelector?: {
				// matchExpressions is a list of label selector requirements. The
				// requirements are ANDed.
				matchExpressions?: [...{
					// key is the label key that the selector applies to.
					key: string

					// operator represents a key's relationship to a set of values.
					// Valid operators are In, NotIn, Exists and DoesNotExist.
					operator: string

					// values is an array of string values. If the operator is In or
					// NotIn, the values array must be non-empty. If the operator is
					// Exists or DoesNotExist, the values array must be empty. This
					// array is replaced during a strategic merge patch.
					values?: [...string]
				}]

				// matchLabels is a map of {key,value} pairs. A single {key,value}
				// in the matchLabels map is equivalent to an element of
				// matchExpressions, whose key field is "key", the operator is
				// "In", and the values array contains only "value". The
				// requirements are ANDed.
				matchLabels?: {
					[string]: string
				}
			}

			// MaxSkew describes the degree to which pods may be unevenly
			// distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the
			// maximum permitted difference between the number of matching
			// pods in the target topology and the global minimum. The global
			// minimum is the minimum number of matching pods in an eligible
			// domain or zero if the number of eligible domains is less than
			// MinDomains. For example, in a 3-zone cluster, MaxSkew is set
			// to 1, and pods with the same labelSelector spread as 2/2/1: In
			// this case, the global minimum is 1. | zone1 | zone2 | zone3 |
			// | P P | P P | P | - if MaxSkew is 1, incoming pod can only be
			// scheduled to zone3 to become 2/2/2; scheduling it onto
			// zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
			// violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be
			// scheduled onto any zone. When
			// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
			// precedence to topologies that satisfy it. It's a required
			// field. Default value is 1 and 0 is not allowed.
			maxSkew: int

			// MinDomains indicates a minimum number of eligible domains. When
			// the number of eligible domains with matching topology keys is
			// less than minDomains, Pod Topology Spread treats "global
			// minimum" as 0, and then the calculation of Skew is performed.
			// And when the number of eligible domains with matching topology
			// keys equals or greater than minDomains, this value has no
			// effect on scheduling. As a result, when the number of eligible
			// domains is less than minDomains, scheduler won't schedule more
			// than maxSkew Pods to those domains. If value is nil, the
			// constraint behaves as if MinDomains is equal to 1. Valid
			// values are integers greater than 0. When value is not nil,
			// WhenUnsatisfiable must be DoNotSchedule.
			// For example, in a 3-zone cluster, MaxSkew is set to 2,
			// MinDomains is set to 5 and pods with the same labelSelector
			// spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P |
			// The number of domains is less than 5(MinDomains), so "global
			// minimum" is treated as 0. In this situation, new pod with the
			// same labelSelector cannot be scheduled, because computed skew
			// will be 3(3 - 0) if new Pod is scheduled to any of the three
			// zones, it will violate MaxSkew.
			// This is an alpha field and requires enabling
			// MinDomainsInPodTopologySpread feature gate.
			minDomains?: int

			// TopologyKey is the key of node labels. Nodes that have a label
			// with this key and identical values are considered to be in the
			// same topology. We consider each <key, value> as a "bucket",
			// and try to put balanced number of pods into each bucket. We
			// define a domain as a particular instance of a topology. Also,
			// we define an eligible domain as a domain whose nodes match the
			// node selector. e.g. If TopologyKey is
			// "kubernetes.io/hostname", each Node is a domain of that
			// topology. And, if TopologyKey is
			// "topology.kubernetes.io/zone", each zone is a domain of that
			// topology. It's a required field.
			topologyKey: string

			// WhenUnsatisfiable indicates how to deal with a pod if it
			// doesn't satisfy the spread constraint. - DoNotSchedule
			// (default) tells the scheduler not to schedule it. -
			// ScheduleAnyway tells the scheduler to schedule the pod in any
			// location, but giving higher precedence to topologies that
			// would help reduce the skew. A constraint is considered
			// "Unsatisfiable" for an incoming pod if and only if every
			// possible node assignment for that pod would violate "MaxSkew"
			// on some topology. For example, in a 3-zone cluster, MaxSkew is
			// set to 1, and pods with the same labelSelector spread as
			// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If
			// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
			// only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
			// ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other
			// words, the cluster can still be imbalanced, but scheduler
			// won't make it *more* imbalanced. It's a required field.
			whenUnsatisfiable: string
		}]

		// Defines a separate PersistentVolumeClaim for PostgreSQL's
		// write-ahead log. More info:
		// https://www.postgresql.org/docs/current/wal.html
		walVolumeClaimSpec?: {
			// accessModes contains the desired access modes the volume should
			// have. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
			accessModes: [...string] & [_, ...]

			// dataSource field can be used to specify either: * An existing
			// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
			// * An existing PVC (PersistentVolumeClaim) If the provisioner
			// or an external controller can support the specified data
			// source, it will create a new volume based on the contents of
			// the specified data source. If the AnyVolumeDataSource feature
			// gate is enabled, this field will always have the same contents
			// as the DataSourceRef field.
			dataSource?: {
				// APIGroup is the group for the resource being referenced. If
				// APIGroup is not specified, the specified Kind must be in the
				// core API group. For any other third-party types, APIGroup is
				// required.
				apiGroup?: string

				// Kind is the type of resource being referenced
				kind: string

				// Name is the name of resource being referenced
				name: string
			}

			// dataSourceRef specifies the object from which to populate the
			// volume with data, if a non-empty volume is desired. This may
			// be any local object from a non-empty API group (non core
			// object) or a PersistentVolumeClaim object. When this field is
			// specified, volume binding will only succeed if the type of the
			// specified object matches some installed volume populator or
			// dynamic provisioner. This field will replace the functionality
			// of the DataSource field and as such if both fields are
			// non-empty, they must have the same value. For backwards
			// compatibility, both fields (DataSource and DataSourceRef) will
			// be set to the same value automatically if one of them is empty
			// and the other is non-empty. There are two important
			// differences between DataSource and DataSourceRef: * While
			// DataSource only allows two specific types of objects,
			// DataSourceRef allows any non-core object, as well as
			// PersistentVolumeClaim objects. * While DataSource ignores
			// disallowed values (dropping them), DataSourceRef preserves all
			// values, and generates an error if a disallowed value is
			// specified. (Beta) Using this field requires the
			// AnyVolumeDataSource feature gate to be enabled.
			dataSourceRef?: {
				// APIGroup is the group for the resource being referenced. If
				// APIGroup is not specified, the specified Kind must be in the
				// core API group. For any other third-party types, APIGroup is
				// required.
				apiGroup?: string

				// Kind is the type of resource being referenced
				kind: string

				// Name is the name of resource being referenced
				name: string
			}

			// resources represents the minimum resources the volume should
			// have. If RecoverVolumeExpansionFailure feature is enabled
			// users are allowed to specify resource requirements that are
			// lower than previous value but must still be higher than
			// capacity recorded in the status field of the claim. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
			resources: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests: {
					{
						[!~"^(storage)$"]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
					storage: _
				}
			}

			// selector is a label query over volumes to consider for binding.
			selector?: {
				// matchExpressions is a list of label selector requirements. The
				// requirements are ANDed.
				matchExpressions?: [...{
					// key is the label key that the selector applies to.
					key: string

					// operator represents a key's relationship to a set of values.
					// Valid operators are In, NotIn, Exists and DoesNotExist.
					operator: string

					// values is an array of string values. If the operator is In or
					// NotIn, the values array must be non-empty. If the operator is
					// Exists or DoesNotExist, the values array must be empty. This
					// array is replaced during a strategic merge patch.
					values?: [...string]
				}]

				// matchLabels is a map of {key,value} pairs. A single {key,value}
				// in the matchLabels map is equivalent to an element of
				// matchExpressions, whose key field is "key", the operator is
				// "In", and the values array contains only "value". The
				// requirements are ANDed.
				matchLabels?: {
					[string]: string
				}
			}

			// storageClassName is the name of the StorageClass required by
			// the claim. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
			storageClassName?: string

			// volumeMode defines what type of volume is required by the
			// claim. Value of Filesystem is implied when not included in
			// claim spec.
			volumeMode?: string

			// volumeName is the binding reference to the PersistentVolume
			// backing this claim.
			volumeName?: string
		}
	}] & [_, ...]

	// Metadata contains metadata for custom resources
	metadata?: {
		annotations?: {
			[string]: string
		}
		labels?: {
			[string]: string
		}
	}
	monitoring?: {
		pgmonitor?: {
			exporter?: {
				// Projected volumes containing custom PostgreSQL Exporter
				// configuration. Currently supports the customization of
				// PostgreSQL Exporter queries. If a "queries.yml" file is
				// detected in any volume projected using this field, it will be
				// loaded using the "extend.query-path" flag:
				// https://github.com/prometheus-community/postgres_exporter#flags
				// Changing the values of field causes PostgreSQL and the
				// exporter to restart.
				configuration?: [...{
					// configMap information about the configMap data to project
					configMap?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced ConfigMap will be projected into the volume as
						// a file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the ConfigMap, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional specify whether the ConfigMap or its keys must be
						// defined
						optional?: bool
					}
					downwardAPI?: {
						// Items is a list of DownwardAPIVolume file
						items?: [...{
							// Required: Selects a field of the pod: only annotations, labels,
							// name and namespace are supported.
							fieldRef?: {
								// Version of the schema the FieldPath is written in terms of,
								// defaults to "v1".
								apiVersion?: string

								// Path of the field to select in the specified API version.
								fieldPath: string
							}

							// Optional: mode bits used to set permissions on this file, must
							// be an octal value between 0000 and 0777 or a decimal value
							// between 0 and 511. YAML accepts both octal and decimal values,
							// JSON requires decimal values for mode bits. If not specified,
							// the volume defaultMode will be used. This might be in conflict
							// with other options that affect the file mode, like fsGroup,
							// and the result can be other mode bits set.
							mode?: int

							// Required: Path is the relative path name of the file to be
							// created. Must not be absolute or contain the '..' path. Must
							// be utf-8 encoded. The first item of the relative path must not
							// start with '..'
							path: string

							// Selects a resource of the container: only resources limits and
							// requests (limits.cpu, limits.memory, requests.cpu and
							// requests.memory) are currently supported.
							resourceFieldRef?: {
								// Container name: required for volumes, optional for env vars
								containerName?: string

								// Specifies the output format of the exposed resources, defaults
								// to "1"
								divisor?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Required: resource to select
								resource: string
							}
						}]
					}

					// secret information about the secret data to project
					secret?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced Secret will be projected into the volume as a
						// file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the Secret, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional field specify whether the Secret or its key must be
						// defined
						optional?: bool
					}

					// serviceAccountToken is information about the
					// serviceAccountToken data to project
					serviceAccountToken?: {
						// audience is the intended audience of the token. A recipient of
						// a token must identify itself with an identifier specified in
						// the audience of the token, and otherwise should reject the
						// token. The audience defaults to the identifier of the
						// apiserver.
						audience?: string

						// expirationSeconds is the requested duration of validity of the
						// service account token. As the token approaches expiration, the
						// kubelet volume plugin will proactively rotate the service
						// account token. The kubelet will start trying to rotate the
						// token if the token is older than 80 percent of its time to
						// live or if the token is older than 24 hours.Defaults to 1 hour
						// and must be at least 10 minutes.
						expirationSeconds?: int

						// path is the path relative to the mount point of the file to
						// project the token into.
						path: string
					}
				}]

				// Projected secret containing custom TLS certificates to encrypt
				// output from the exporter web server
				customTLSSecret?: {
					// items if unspecified, each key-value pair in the Data field of
					// the referenced Secret will be projected into the volume as a
					// file whose name is the key and content is the value. If
					// specified, the listed keys will be projected into the
					// specified paths, and unlisted keys will not be present. If a
					// key is specified which is not present in the Secret, the
					// volume setup will error unless it is marked optional. Paths
					// must be relative and may not contain the '..' path or start
					// with '..'.
					items?: [...{
						// key is the key to project.
						key: string

						// mode is Optional: mode bits used to set permissions on this
						// file. Must be an octal value between 0000 and 0777 or a
						// decimal value between 0 and 511. YAML accepts both octal and
						// decimal values, JSON requires decimal values for mode bits. If
						// not specified, the volume defaultMode will be used. This might
						// be in conflict with other options that affect the file mode,
						// like fsGroup, and the result can be other mode bits set.
						mode?: int

						// path is the relative path of the file to map the key to. May
						// not be an absolute path. May not contain the path element
						// '..'. May not start with the string '..'.
						path: string
					}]

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// optional field specify whether the Secret or its key must be
					// defined
					optional?: bool
				}

				// The image name to use for crunchy-postgres-exporter containers.
				// The image may also be set using the RELATED_IMAGE_PGEXPORTER
				// environment variable.
				image?: string

				// Changing this value causes PostgreSQL and the exporter to
				// restart. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}
			}
		}
	}

	// Whether or not the PostgreSQL cluster is being deployed to an
	// OpenShift environment. If the field is unset, the operator
	// will automatically detect the environment.
	openshift?: bool
	patroni?: {
		// Patroni dynamic configuration settings. Changes to this value
		// will be automatically reloaded without validation. Changes to
		// certain PostgreSQL parameters cause PostgreSQL to restart.
		// More info:
		// https://patroni.readthedocs.io/en/latest/SETTINGS.html
		dynamicConfiguration?: {
			...
		}

		// TTL of the cluster leader lock. "Think of it as the length of
		// time before initiation of the automatic failover process."
		// Changing this value causes PostgreSQL to restart.
		leaderLeaseDurationSeconds?: int & >=3 | *30

		// The port on which Patroni should listen. Changing this value
		// causes PostgreSQL to restart.
		port?: int & >=1024 | *8008

		// Switchover gives options to perform ad hoc switchovers in a
		// PostgresCluster.
		switchover?: {
			// Whether or not the operator should allow switchovers in a
			// PostgresCluster
			enabled: bool

			// The instance that should become primary during a switchover.
			// This field is optional when Type is "Switchover" and required
			// when Type is "Failover". When it is not specified, a healthy
			// replica is automatically selected.
			targetInstance?: string

			// Type of switchover to perform. Valid options are Switchover and
			// Failover. "Switchover" changes the primary instance of a
			// healthy PostgresCluster. "Failover" forces a particular
			// instance to be primary, regardless of other factors. A
			// TargetInstance must be specified to failover. NOTE: The
			// Failover type is reserved as the "last resort" case.
			type?: "Switchover" | "Failover" | *"Switchover"
		}

		// The interval for refreshing the leader lock and applying
		// dynamicConfiguration. Must be less than
		// leaderLeaseDurationSeconds. Changing this value causes
		// PostgreSQL to restart.
		syncPeriodSeconds?: int & >=1 | *10
	}

	// Suspends the rollout and reconciliation of changes made to the
	// PostgresCluster spec.
	paused?: bool

	// The port on which PostgreSQL should listen.
	port?: int & >=1024 | *5432

	// The PostGIS extension version installed in the PostgreSQL
	// image. When image is not set, indicates a PostGIS enabled
	// image will be used.
	postGISVersion?: string

	// The major version of PostgreSQL installed in the PostgreSQL
	// image
	postgresVersion: uint & >=10 & <=16
	proxy?: {
		// Defines a PgBouncer proxy and connection pooler.
		pgBouncer: {
			// Scheduling constraints of a PgBouncer pod. Changing this value
			// causes PgBouncer to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node matches the
					// corresponding matchExpressions; the node(s) with the highest
					// sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node has pods which matches
					// the corresponding podAffinityTerm; the node(s) with the
					// highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at scheduling time, the pod will not be scheduled onto the
					// node. If the affinity requirements specified by this field
					// cease to be met at some point during pod execution (e.g. due
					// to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the anti-affinity expressions specified by this field,
					// but it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling anti-affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding "weight" to the sum if the node has pods which
					// matches the corresponding podAffinityTerm; the node(s) with
					// the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at scheduling time, the pod will not be scheduled onto
					// the node. If the anti-affinity requirements specified by this
					// field cease to be met at some point during pod execution (e.g.
					// due to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// Configuration settings for the PgBouncer process. Changes to
			// any of these values will be automatically reloaded without
			// validation. Be careful, as you may put PgBouncer into an
			// unusable state. More info:
			// https://www.pgbouncer.org/usage.html#reload
			config?: {
				// PgBouncer database definitions. The key is the database
				// requested by a client while the value is a libpq-styled
				// connection string. The special key "*" acts as a fallback.
				// When this field is empty, PgBouncer is configured with a
				// single "*" entry that connects to the primary PostgreSQL
				// instance. More info:
				// https://www.pgbouncer.org/config.html#section-databases
				databases?: {
					[string]: string
				}

				// Files to mount under "/etc/pgbouncer". When specified, settings
				// in the "pgbouncer.ini" file are loaded before all others. From
				// there, other files may be included by absolute path. Changing
				// these references causes PgBouncer to restart, but changes to
				// the file contents are automatically reloaded. More info:
				// https://www.pgbouncer.org/config.html#include-directive
				files?: [...{
					// configMap information about the configMap data to project
					configMap?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced ConfigMap will be projected into the volume as
						// a file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the ConfigMap, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional specify whether the ConfigMap or its keys must be
						// defined
						optional?: bool
					}
					downwardAPI?: {
						// Items is a list of DownwardAPIVolume file
						items?: [...{
							// Required: Selects a field of the pod: only annotations, labels,
							// name and namespace are supported.
							fieldRef?: {
								// Version of the schema the FieldPath is written in terms of,
								// defaults to "v1".
								apiVersion?: string

								// Path of the field to select in the specified API version.
								fieldPath: string
							}

							// Optional: mode bits used to set permissions on this file, must
							// be an octal value between 0000 and 0777 or a decimal value
							// between 0 and 511. YAML accepts both octal and decimal values,
							// JSON requires decimal values for mode bits. If not specified,
							// the volume defaultMode will be used. This might be in conflict
							// with other options that affect the file mode, like fsGroup,
							// and the result can be other mode bits set.
							mode?: int

							// Required: Path is the relative path name of the file to be
							// created. Must not be absolute or contain the '..' path. Must
							// be utf-8 encoded. The first item of the relative path must not
							// start with '..'
							path: string

							// Selects a resource of the container: only resources limits and
							// requests (limits.cpu, limits.memory, requests.cpu and
							// requests.memory) are currently supported.
							resourceFieldRef?: {
								// Container name: required for volumes, optional for env vars
								containerName?: string

								// Specifies the output format of the exposed resources, defaults
								// to "1"
								divisor?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Required: resource to select
								resource: string
							}
						}]
					}

					// secret information about the secret data to project
					secret?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced Secret will be projected into the volume as a
						// file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the Secret, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional field specify whether the Secret or its key must be
						// defined
						optional?: bool
					}

					// serviceAccountToken is information about the
					// serviceAccountToken data to project
					serviceAccountToken?: {
						// audience is the intended audience of the token. A recipient of
						// a token must identify itself with an identifier specified in
						// the audience of the token, and otherwise should reject the
						// token. The audience defaults to the identifier of the
						// apiserver.
						audience?: string

						// expirationSeconds is the requested duration of validity of the
						// service account token. As the token approaches expiration, the
						// kubelet volume plugin will proactively rotate the service
						// account token. The kubelet will start trying to rotate the
						// token if the token is older than 80 percent of its time to
						// live or if the token is older than 24 hours.Defaults to 1 hour
						// and must be at least 10 minutes.
						expirationSeconds?: int

						// path is the path relative to the mount point of the file to
						// project the token into.
						path: string
					}
				}]

				// Settings that apply to the entire PgBouncer process. More info:
				// https://www.pgbouncer.org/config.html
				global?: {
					[string]: string
				}

				// Connection settings specific to particular users. More info:
				// https://www.pgbouncer.org/config.html#section-users
				users?: {
					[string]: string
				}
			}

			// Custom sidecars for a PgBouncer pod. Changing this value causes
			// PgBouncer to restart.
			containers?: [...{
				// Arguments to the entrypoint. The container image's CMD is used
				// if this is not provided. Variable references $(VAR_NAME) are
				// expanded using the container's environment. If a variable
				// cannot be resolved, the reference in the input string will be
				// unchanged. Double $$ are reduced to a single $, which allows
				// for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
				// produce the string literal "$(VAR_NAME)". Escaped references
				// will never be expanded, regardless of whether the variable
				// exists or not. Cannot be updated. More info:
				// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
				args?: [...string]

				// Entrypoint array. Not executed within a shell. The container
				// image's ENTRYPOINT is used if this is not provided. Variable
				// references $(VAR_NAME) are expanded using the container's
				// environment. If a variable cannot be resolved, the reference
				// in the input string will be unchanged. Double $$ are reduced
				// to a single $, which allows for escaping the $(VAR_NAME)
				// syntax: i.e. "$$(VAR_NAME)" will produce the string literal
				// "$(VAR_NAME)". Escaped references will never be expanded,
				// regardless of whether the variable exists or not. Cannot be
				// updated. More info:
				// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
				command?: [...string]

				// List of environment variables to set in the container. Cannot
				// be updated.
				env?: [...{
					// Name of the environment variable. Must be a C_IDENTIFIER.
					name: string

					// Variable references $(VAR_NAME) are expanded using the
					// previously defined environment variables in the container and
					// any service environment variables. If a variable cannot be
					// resolved, the reference in the input string will be unchanged.
					// Double $$ are reduced to a single $, which allows for escaping
					// the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the
					// string literal "$(VAR_NAME)". Escaped references will never be
					// expanded, regardless of whether the variable exists or not.
					// Defaults to "".
					value?: string

					// Source for the environment variable's value. Cannot be used if
					// value is not empty.
					valueFrom?: {
						// Selects a key of a ConfigMap.
						configMapKeyRef?: {
							// The key to select.
							key: string

							// Name of the referent. More info:
							// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
							name?: string

							// Specify whether the ConfigMap or its key must be defined
							optional?: bool
						}

						// Selects a field of the pod: supports metadata.name,
						// metadata.namespace, `metadata.labels['<KEY>']`,
						// `metadata.annotations['<KEY>']`, spec.nodeName,
						// spec.serviceAccountName, status.hostIP, status.podIP,
						// status.podIPs.
						fieldRef?: {
							// Version of the schema the FieldPath is written in terms of,
							// defaults to "v1".
							apiVersion?: string

							// Path of the field to select in the specified API version.
							fieldPath: string
						}

						// Selects a resource of the container: only resources limits and
						// requests (limits.cpu, limits.memory, limits.ephemeral-storage,
						// requests.cpu, requests.memory and requests.ephemeral-storage)
						// are currently supported.
						resourceFieldRef?: {
							// Container name: required for volumes, optional for env vars
							containerName?: string

							// Specifies the output format of the exposed resources, defaults
							// to "1"
							divisor?: (int | string) & {
								=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Required: resource to select
							resource: string
						}

						// Selects a key of a secret in the pod's namespace
						secretKeyRef?: {
							// The key of the secret to select from. Must be a valid secret
							// key.
							key: string

							// Name of the referent. More info:
							// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
							name?: string

							// Specify whether the Secret or its key must be defined
							optional?: bool
						}
					}
				}]

				// List of sources to populate environment variables in the
				// container. The keys defined within a source must be a
				// C_IDENTIFIER. All invalid keys will be reported as an event
				// when the container is starting. When a key exists in multiple
				// sources, the value associated with the last source will take
				// precedence. Values defined by an Env with a duplicate key will
				// take precedence. Cannot be updated.
				envFrom?: [...{
					// The ConfigMap to select from
					configMapRef?: {
						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the ConfigMap must be defined
						optional?: bool
					}

					// An optional identifier to prepend to each key in the ConfigMap.
					// Must be a C_IDENTIFIER.
					prefix?: string

					// The Secret to select from
					secretRef?: {
						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the Secret must be defined
						optional?: bool
					}
				}]

				// Container image name. More info:
				// https://kubernetes.io/docs/concepts/containers/images This
				// field is optional to allow higher level config management to
				// default or override container images in workload controllers
				// like Deployments and StatefulSets.
				image?: string

				// Image pull policy. One of Always, Never, IfNotPresent. Defaults
				// to Always if :latest tag is specified, or IfNotPresent
				// otherwise. Cannot be updated. More info:
				// https://kubernetes.io/docs/concepts/containers/images#updating-images
				imagePullPolicy?: string

				// Actions that the management system should take in response to
				// container lifecycle events. Cannot be updated.
				lifecycle?: {
					// PostStart is called immediately after a container is created.
					// If the handler fails, the container is terminated and
					// restarted according to its restart policy. Other management of
					// the container blocks until the hook completes. More info:
					// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
					postStart?: {
						exec?: {
							// Command is the command line to execute inside the container,
							// the working directory for the command is root ('/') in the
							// container's filesystem. The command is simply exec'd, it is
							// not run inside a shell, so traditional shell instructions
							// ('|', etc) won't work. To use a shell, you need to explicitly
							// call out to that shell. Exit status of 0 is treated as
							// live/healthy and non-zero is unhealthy.
							command?: [...string]
						}

						// HTTPGet specifies the http request to perform.
						httpGet?: {
							// Host name to connect to, defaults to the pod IP. You probably
							// want to set "Host" in httpHeaders instead.
							host?: string

							// Custom headers to set in the request. HTTP allows repeated
							// headers.
							httpHeaders?: [...{
								// The header field name
								name: string

								// The header field value
								value: string
							}]

							// Path to access on the HTTP server.
							path?: string

							// Name or number of the port to access on the container. Number
							// must be in the range 1 to 65535. Name must be an
							// IANA_SVC_NAME.
							port: (int | string) & {
								string
							}

							// Scheme to use for connecting to the host. Defaults to HTTP.
							scheme?: string
						}

						// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
						// and kept for the backward compatibility. There are no
						// validation of this field and lifecycle hooks will fail in
						// runtime when tcp handler is specified.
						tcpSocket?: {
							// Optional: Host name to connect to, defaults to the pod IP.
							host?: string

							// Number or name of the port to access on the container. Number
							// must be in the range 1 to 65535. Name must be an
							// IANA_SVC_NAME.
							port: (int | string) & {
								string
							}
						}
					}

					// PreStop is called immediately before a container is terminated
					// due to an API request or management event such as
					// liveness/startup probe failure, preemption, resource
					// contention, etc. The handler is not called if the container
					// crashes or exits. The Pod's termination grace period countdown
					// begins before the PreStop hook is executed. Regardless of the
					// outcome of the handler, the container will eventually
					// terminate within the Pod's termination grace period (unless
					// delayed by finalizers). Other management of the container
					// blocks until the hook completes or until the termination grace
					// period is reached. More info:
					// https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
					preStop?: {
						exec?: {
							// Command is the command line to execute inside the container,
							// the working directory for the command is root ('/') in the
							// container's filesystem. The command is simply exec'd, it is
							// not run inside a shell, so traditional shell instructions
							// ('|', etc) won't work. To use a shell, you need to explicitly
							// call out to that shell. Exit status of 0 is treated as
							// live/healthy and non-zero is unhealthy.
							command?: [...string]
						}

						// HTTPGet specifies the http request to perform.
						httpGet?: {
							// Host name to connect to, defaults to the pod IP. You probably
							// want to set "Host" in httpHeaders instead.
							host?: string

							// Custom headers to set in the request. HTTP allows repeated
							// headers.
							httpHeaders?: [...{
								// The header field name
								name: string

								// The header field value
								value: string
							}]

							// Path to access on the HTTP server.
							path?: string

							// Name or number of the port to access on the container. Number
							// must be in the range 1 to 65535. Name must be an
							// IANA_SVC_NAME.
							port: (int | string) & {
								string
							}

							// Scheme to use for connecting to the host. Defaults to HTTP.
							scheme?: string
						}

						// Deprecated. TCPSocket is NOT supported as a LifecycleHandler
						// and kept for the backward compatibility. There are no
						// validation of this field and lifecycle hooks will fail in
						// runtime when tcp handler is specified.
						tcpSocket?: {
							// Optional: Host name to connect to, defaults to the pod IP.
							host?: string

							// Number or name of the port to access on the container. Number
							// must be in the range 1 to 65535. Name must be an
							// IANA_SVC_NAME.
							port: (int | string) & {
								string
							}
						}
					}
				}

				// Periodic probe of container liveness. Container will be
				// restarted if the probe fails. Cannot be updated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				livenessProbe?: {
					exec?: {
						// Command is the command line to execute inside the container,
						// the working directory for the command is root ('/') in the
						// container's filesystem. The command is simply exec'd, it is
						// not run inside a shell, so traditional shell instructions
						// ('|', etc) won't work. To use a shell, you need to explicitly
						// call out to that shell. Exit status of 0 is treated as
						// live/healthy and non-zero is unhealthy.
						command?: [...string]
					}

					// Minimum consecutive failures for the probe to be considered
					// failed after having succeeded. Defaults to 3. Minimum value is
					// 1.
					failureThreshold?: int

					// GRPC specifies an action involving a GRPC port. This is a beta
					// field and requires enabling GRPCContainerProbe feature gate.
					grpc?: {
						// Port number of the gRPC service. Number must be in the range 1
						// to 65535.
						port: int

						// Service is the name of the service to place in the gRPC
						// HealthCheckRequest (see
						// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
						// If this is not specified, the default behavior is defined by
						// gRPC.
						service?: string
					}

					// HTTPGet specifies the http request to perform.
					httpGet?: {
						// Host name to connect to, defaults to the pod IP. You probably
						// want to set "Host" in httpHeaders instead.
						host?: string

						// Custom headers to set in the request. HTTP allows repeated
						// headers.
						httpHeaders?: [...{
							// The header field name
							name: string

							// The header field value
							value: string
						}]

						// Path to access on the HTTP server.
						path?: string

						// Name or number of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}

						// Scheme to use for connecting to the host. Defaults to HTTP.
						scheme?: string
					}

					// Number of seconds after the container has started before
					// liveness probes are initiated. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					initialDelaySeconds?: int

					// How often (in seconds) to perform the probe. Default to 10
					// seconds. Minimum value is 1.
					periodSeconds?: int

					// Minimum consecutive successes for the probe to be considered
					// successful after having failed. Defaults to 1. Must be 1 for
					// liveness and startup. Minimum value is 1.
					successThreshold?: int

					// TCPSocket specifies an action involving a TCP port.
					tcpSocket?: {
						// Optional: Host name to connect to, defaults to the pod IP.
						host?: string

						// Number or name of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}
					}

					// Optional duration in seconds the pod needs to terminate
					// gracefully upon probe failure. The grace period is the
					// duration in seconds after the processes running in the pod are
					// sent a termination signal and the time when the processes are
					// forcibly halted with a kill signal. Set this value longer than
					// the expected cleanup time for your process. If this value is
					// nil, the pod's terminationGracePeriodSeconds will be used.
					// Otherwise, this value overrides the value provided by the pod
					// spec. Value must be non-negative integer. The value zero
					// indicates stop immediately via the kill signal (no opportunity
					// to shut down). This is a beta field and requires enabling
					// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
					// spec.terminationGracePeriodSeconds is used if unset.
					terminationGracePeriodSeconds?: int

					// Number of seconds after which the probe times out. Defaults to
					// 1 second. Minimum value is 1. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					timeoutSeconds?: int
				}

				// Name of the container specified as a DNS_LABEL. Each container
				// in a pod must have a unique name (DNS_LABEL). Cannot be
				// updated.
				name: string

				// List of ports to expose from the container. Exposing a port
				// here gives the system additional information about the network
				// connections a container uses, but is primarily informational.
				// Not specifying a port here DOES NOT prevent that port from
				// being exposed. Any port which is listening on the default
				// "0.0.0.0" address inside a container will be accessible from
				// the network. Cannot be updated.
				ports?: [...{
					// Number of port to expose on the pod's IP address. This must be
					// a valid port number, 0 < x < 65536.
					containerPort: int

					// What host IP to bind the external port to.
					hostIP?: string

					// Number of port to expose on the host. If specified, this must
					// be a valid port number, 0 < x < 65536. If HostNetwork is
					// specified, this must match ContainerPort. Most containers do
					// not need this.
					hostPort?: int

					// If specified, this must be an IANA_SVC_NAME and unique within
					// the pod. Each named port in a pod must have a unique name.
					// Name for the port that can be referred to by services.
					name?: string

					// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to
					// "TCP".
					protocol?: string | *"TCP"
				}]

				// Periodic probe of container service readiness. Container will
				// be removed from service endpoints if the probe fails. Cannot
				// be updated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				readinessProbe?: {
					exec?: {
						// Command is the command line to execute inside the container,
						// the working directory for the command is root ('/') in the
						// container's filesystem. The command is simply exec'd, it is
						// not run inside a shell, so traditional shell instructions
						// ('|', etc) won't work. To use a shell, you need to explicitly
						// call out to that shell. Exit status of 0 is treated as
						// live/healthy and non-zero is unhealthy.
						command?: [...string]
					}

					// Minimum consecutive failures for the probe to be considered
					// failed after having succeeded. Defaults to 3. Minimum value is
					// 1.
					failureThreshold?: int

					// GRPC specifies an action involving a GRPC port. This is a beta
					// field and requires enabling GRPCContainerProbe feature gate.
					grpc?: {
						// Port number of the gRPC service. Number must be in the range 1
						// to 65535.
						port: int

						// Service is the name of the service to place in the gRPC
						// HealthCheckRequest (see
						// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
						// If this is not specified, the default behavior is defined by
						// gRPC.
						service?: string
					}

					// HTTPGet specifies the http request to perform.
					httpGet?: {
						// Host name to connect to, defaults to the pod IP. You probably
						// want to set "Host" in httpHeaders instead.
						host?: string

						// Custom headers to set in the request. HTTP allows repeated
						// headers.
						httpHeaders?: [...{
							// The header field name
							name: string

							// The header field value
							value: string
						}]

						// Path to access on the HTTP server.
						path?: string

						// Name or number of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}

						// Scheme to use for connecting to the host. Defaults to HTTP.
						scheme?: string
					}

					// Number of seconds after the container has started before
					// liveness probes are initiated. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					initialDelaySeconds?: int

					// How often (in seconds) to perform the probe. Default to 10
					// seconds. Minimum value is 1.
					periodSeconds?: int

					// Minimum consecutive successes for the probe to be considered
					// successful after having failed. Defaults to 1. Must be 1 for
					// liveness and startup. Minimum value is 1.
					successThreshold?: int

					// TCPSocket specifies an action involving a TCP port.
					tcpSocket?: {
						// Optional: Host name to connect to, defaults to the pod IP.
						host?: string

						// Number or name of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}
					}

					// Optional duration in seconds the pod needs to terminate
					// gracefully upon probe failure. The grace period is the
					// duration in seconds after the processes running in the pod are
					// sent a termination signal and the time when the processes are
					// forcibly halted with a kill signal. Set this value longer than
					// the expected cleanup time for your process. If this value is
					// nil, the pod's terminationGracePeriodSeconds will be used.
					// Otherwise, this value overrides the value provided by the pod
					// spec. Value must be non-negative integer. The value zero
					// indicates stop immediately via the kill signal (no opportunity
					// to shut down). This is a beta field and requires enabling
					// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
					// spec.terminationGracePeriodSeconds is used if unset.
					terminationGracePeriodSeconds?: int

					// Number of seconds after which the probe times out. Defaults to
					// 1 second. Minimum value is 1. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					timeoutSeconds?: int
				}

				// Compute Resources required by this container. Cannot be
				// updated. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// SecurityContext defines the security options the container
				// should be run with. If set, the fields of SecurityContext
				// override the equivalent fields of PodSecurityContext. More
				// info:
				// https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
				securityContext?: {
					// AllowPrivilegeEscalation controls whether a process can gain
					// more privileges than its parent process. This bool directly
					// controls if the no_new_privs flag will be set on the container
					// process. AllowPrivilegeEscalation is true always when the
					// container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note
					// that this field cannot be set when spec.os.name is windows.
					allowPrivilegeEscalation?: bool

					// The capabilities to add/drop when running containers. Defaults
					// to the default set of capabilities granted by the container
					// runtime. Note that this field cannot be set when spec.os.name
					// is windows.
					capabilities?: {
						// Added capabilities
						add?: [...string]

						// Removed capabilities
						drop?: [...string]
					}

					// Run container in privileged mode. Processes in privileged
					// containers are essentially equivalent to root on the host.
					// Defaults to false. Note that this field cannot be set when
					// spec.os.name is windows.
					privileged?: bool

					// procMount denotes the type of proc mount to use for the
					// containers. The default is DefaultProcMount which uses the
					// container runtime defaults for readonly paths and masked
					// paths. This requires the ProcMountType feature flag to be
					// enabled. Note that this field cannot be set when spec.os.name
					// is windows.
					procMount?: string

					// Whether this container has a read-only root filesystem. Default
					// is false. Note that this field cannot be set when spec.os.name
					// is windows.
					readOnlyRootFilesystem?: bool

					// The GID to run the entrypoint of the container process. Uses
					// runtime default if unset. May also be set in
					// PodSecurityContext. If set in both SecurityContext and
					// PodSecurityContext, the value specified in SecurityContext
					// takes precedence. Note that this field cannot be set when
					// spec.os.name is windows.
					runAsGroup?: int

					// Indicates that the container must run as a non-root user. If
					// true, the Kubelet will validate the image at runtime to ensure
					// that it does not run as UID 0 (root) and fail to start the
					// container if it does. If unset or false, no such validation
					// will be performed. May also be set in PodSecurityContext. If
					// set in both SecurityContext and PodSecurityContext, the value
					// specified in SecurityContext takes precedence.
					runAsNonRoot?: bool

					// The UID to run the entrypoint of the container process.
					// Defaults to user specified in image metadata if unspecified.
					// May also be set in PodSecurityContext. If set in both
					// SecurityContext and PodSecurityContext, the value specified in
					// SecurityContext takes precedence. Note that this field cannot
					// be set when spec.os.name is windows.
					runAsUser?: int

					// The SELinux context to be applied to the container. If
					// unspecified, the container runtime will allocate a random
					// SELinux context for each container. May also be set in
					// PodSecurityContext. If set in both SecurityContext and
					// PodSecurityContext, the value specified in SecurityContext
					// takes precedence. Note that this field cannot be set when
					// spec.os.name is windows.
					seLinuxOptions?: {
						// Level is SELinux level label that applies to the container.
						level?: string

						// Role is a SELinux role label that applies to the container.
						role?: string

						// Type is a SELinux type label that applies to the container.
						type?: string

						// User is a SELinux user label that applies to the container.
						user?: string
					}

					// The seccomp options to use by this container. If seccomp
					// options are provided at both the pod & container level, the
					// container options override the pod options. Note that this
					// field cannot be set when spec.os.name is windows.
					seccompProfile?: {
						// localhostProfile indicates a profile defined in a file on the
						// node should be used. The profile must be preconfigured on the
						// node to work. Must be a descending path, relative to the
						// kubelet's configured seccomp profile location. Must only be
						// set if type is "Localhost".
						localhostProfile?: string

						// type indicates which kind of seccomp profile will be applied.
						// Valid options are: Localhost - a profile defined in a file on
						// the node should be used. RuntimeDefault - the container
						// runtime default profile should be used. Unconfined - no
						// profile should be applied.
						type: string
					}

					// The Windows specific settings applied to all containers. If
					// unspecified, the options from the PodSecurityContext will be
					// used. If set in both SecurityContext and PodSecurityContext,
					// the value specified in SecurityContext takes precedence. Note
					// that this field cannot be set when spec.os.name is linux.
					windowsOptions?: {
						// GMSACredentialSpec is where the GMSA admission webhook
						// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
						// contents of the GMSA credential spec named by the
						// GMSACredentialSpecName field.
						gmsaCredentialSpec?: string

						// GMSACredentialSpecName is the name of the GMSA credential spec
						// to use.
						gmsaCredentialSpecName?: string

						// HostProcess determines if a container should be run as a 'Host
						// Process' container. This field is alpha-level and will only be
						// honored by components that enable the
						// WindowsHostProcessContainers feature flag. Setting this field
						// without the feature flag will result in errors when validating
						// the Pod. All of a Pod's containers must have the same
						// effective HostProcess value (it is not allowed to have a mix
						// of HostProcess containers and non-HostProcess containers). In
						// addition, if HostProcess is true then HostNetwork must also be
						// set to true.
						hostProcess?: bool

						// The UserName in Windows to run the entrypoint of the container
						// process. Defaults to the user specified in image metadata if
						// unspecified. May also be set in PodSecurityContext. If set in
						// both SecurityContext and PodSecurityContext, the value
						// specified in SecurityContext takes precedence.
						runAsUserName?: string
					}
				}

				// StartupProbe indicates that the Pod has successfully
				// initialized. If specified, no other probes are executed until
				// this completes successfully. If this probe fails, the Pod will
				// be restarted, just as if the livenessProbe failed. This can be
				// used to provide different probe parameters at the beginning of
				// a Pod's lifecycle, when it might take a long time to load data
				// or warm a cache, than during steady-state operation. This
				// cannot be updated. More info:
				// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
				startupProbe?: {
					exec?: {
						// Command is the command line to execute inside the container,
						// the working directory for the command is root ('/') in the
						// container's filesystem. The command is simply exec'd, it is
						// not run inside a shell, so traditional shell instructions
						// ('|', etc) won't work. To use a shell, you need to explicitly
						// call out to that shell. Exit status of 0 is treated as
						// live/healthy and non-zero is unhealthy.
						command?: [...string]
					}

					// Minimum consecutive failures for the probe to be considered
					// failed after having succeeded. Defaults to 3. Minimum value is
					// 1.
					failureThreshold?: int

					// GRPC specifies an action involving a GRPC port. This is a beta
					// field and requires enabling GRPCContainerProbe feature gate.
					grpc?: {
						// Port number of the gRPC service. Number must be in the range 1
						// to 65535.
						port: int

						// Service is the name of the service to place in the gRPC
						// HealthCheckRequest (see
						// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
						// If this is not specified, the default behavior is defined by
						// gRPC.
						service?: string
					}

					// HTTPGet specifies the http request to perform.
					httpGet?: {
						// Host name to connect to, defaults to the pod IP. You probably
						// want to set "Host" in httpHeaders instead.
						host?: string

						// Custom headers to set in the request. HTTP allows repeated
						// headers.
						httpHeaders?: [...{
							// The header field name
							name: string

							// The header field value
							value: string
						}]

						// Path to access on the HTTP server.
						path?: string

						// Name or number of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}

						// Scheme to use for connecting to the host. Defaults to HTTP.
						scheme?: string
					}

					// Number of seconds after the container has started before
					// liveness probes are initiated. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					initialDelaySeconds?: int

					// How often (in seconds) to perform the probe. Default to 10
					// seconds. Minimum value is 1.
					periodSeconds?: int

					// Minimum consecutive successes for the probe to be considered
					// successful after having failed. Defaults to 1. Must be 1 for
					// liveness and startup. Minimum value is 1.
					successThreshold?: int

					// TCPSocket specifies an action involving a TCP port.
					tcpSocket?: {
						// Optional: Host name to connect to, defaults to the pod IP.
						host?: string

						// Number or name of the port to access on the container. Number
						// must be in the range 1 to 65535. Name must be an
						// IANA_SVC_NAME.
						port: (int | string) & {
							string
						}
					}

					// Optional duration in seconds the pod needs to terminate
					// gracefully upon probe failure. The grace period is the
					// duration in seconds after the processes running in the pod are
					// sent a termination signal and the time when the processes are
					// forcibly halted with a kill signal. Set this value longer than
					// the expected cleanup time for your process. If this value is
					// nil, the pod's terminationGracePeriodSeconds will be used.
					// Otherwise, this value overrides the value provided by the pod
					// spec. Value must be non-negative integer. The value zero
					// indicates stop immediately via the kill signal (no opportunity
					// to shut down). This is a beta field and requires enabling
					// ProbeTerminationGracePeriod feature gate. Minimum value is 1.
					// spec.terminationGracePeriodSeconds is used if unset.
					terminationGracePeriodSeconds?: int

					// Number of seconds after which the probe times out. Defaults to
					// 1 second. Minimum value is 1. More info:
					// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
					timeoutSeconds?: int
				}

				// Whether this container should allocate a buffer for stdin in
				// the container runtime. If this is not set, reads from stdin in
				// the container will always result in EOF. Default is false.
				stdin?: bool

				// Whether the container runtime should close the stdin channel
				// after it has been opened by a single attach. When stdin is
				// true the stdin stream will remain open across multiple attach
				// sessions. If stdinOnce is set to true, stdin is opened on
				// container start, is empty until the first client attaches to
				// stdin, and then remains open and accepts data until the client
				// disconnects, at which time stdin is closed and remains closed
				// until the container is restarted. If this flag is false, a
				// container processes that reads from stdin will never receive
				// an EOF. Default is false
				stdinOnce?: bool

				// Optional: Path at which the file to which the container's
				// termination message will be written is mounted into the
				// container's filesystem. Message written is intended to be
				// brief final status, such as an assertion failure message. Will
				// be truncated by the node if greater than 4096 bytes. The total
				// message length across all containers will be limited to 12kb.
				// Defaults to /dev/termination-log. Cannot be updated.
				terminationMessagePath?: string

				// Indicate how the termination message should be populated. File
				// will use the contents of terminationMessagePath to populate
				// the container status message on both success and failure.
				// FallbackToLogsOnError will use the last chunk of container log
				// output if the termination message file is empty and the
				// container exited with an error. The log output is limited to
				// 2048 bytes or 80 lines, whichever is smaller. Defaults to
				// File. Cannot be updated.
				terminationMessagePolicy?: string

				// Whether this container should allocate a TTY for itself, also
				// requires 'stdin' to be true. Default is false.
				tty?: bool

				// volumeDevices is the list of block devices to be used by the
				// container.
				volumeDevices?: [...{
					// devicePath is the path inside of the container that the device
					// will be mapped to.
					devicePath: string

					// name must match the name of a persistentVolumeClaim in the pod
					name: string
				}]

				// Pod volumes to mount into the container's filesystem. Cannot be
				// updated.
				volumeMounts?: [...{
					// Path within the container at which the volume should be
					// mounted. Must not contain ':'.
					mountPath: string

					// mountPropagation determines how mounts are propagated from the
					// host to container and the other way around. When not set,
					// MountPropagationNone is used. This field is beta in 1.10.
					mountPropagation?: string

					// This must match the Name of a Volume.
					name: string

					// Mounted read-only if true, read-write otherwise (false or
					// unspecified). Defaults to false.
					readOnly?: bool

					// Path within the volume from which the container's volume should
					// be mounted. Defaults to "" (volume's root).
					subPath?: string

					// Expanded path within the volume from which the container's
					// volume should be mounted. Behaves similarly to SubPath but
					// environment variable references $(VAR_NAME) are expanded using
					// the container's environment. Defaults to "" (volume's root).
					// SubPathExpr and SubPath are mutually exclusive.
					subPathExpr?: string
				}]

				// Container's working directory. If not specified, the container
				// runtime's default will be used, which might be configured in
				// the container image. Cannot be updated.
				workingDir?: string
			}]

			// A secret projection containing a certificate and key with which
			// to encrypt connections to PgBouncer. The "tls.crt", "tls.key",
			// and "ca.crt" paths must be PEM-encoded certificates and keys.
			// Changing this value causes PgBouncer to restart. More info:
			// https://kubernetes.io/docs/concepts/configuration/secret/#projection-of-secret-keys-to-specific-paths
			customTLSSecret?: {
				// items if unspecified, each key-value pair in the Data field of
				// the referenced Secret will be projected into the volume as a
				// file whose name is the key and content is the value. If
				// specified, the listed keys will be projected into the
				// specified paths, and unlisted keys will not be present. If a
				// key is specified which is not present in the Secret, the
				// volume setup will error unless it is marked optional. Paths
				// must be relative and may not contain the '..' path or start
				// with '..'.
				items?: [...{
					// key is the key to project.
					key: string

					// mode is Optional: mode bits used to set permissions on this
					// file. Must be an octal value between 0000 and 0777 or a
					// decimal value between 0 and 511. YAML accepts both octal and
					// decimal values, JSON requires decimal values for mode bits. If
					// not specified, the volume defaultMode will be used. This might
					// be in conflict with other options that affect the file mode,
					// like fsGroup, and the result can be other mode bits set.
					mode?: int

					// path is the relative path of the file to map the key to. May
					// not be an absolute path. May not contain the path element
					// '..'. May not start with the string '..'.
					path: string
				}]

				// Name of the referent. More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// optional field specify whether the Secret or its key must be
				// defined
				optional?: bool
			}

			// Name of a container image that can run PgBouncer 1.15 or newer.
			// Changing this value causes PgBouncer to restart. The image may
			// also be set using the RELATED_IMAGE_PGBOUNCER environment
			// variable. More info:
			// https://kubernetes.io/docs/concepts/containers/images
			image?: string

			// Metadata contains metadata for custom resources
			metadata?: {
				annotations?: {
					[string]: string
				}
				labels?: {
					[string]: string
				}
			}

			// Minimum number of pods that should be available at a time.
			// Defaults to one when the replicas field is greater than one.
			minAvailable?: (int | string) & {
				string
			}

			// Port on which PgBouncer should listen for client connections.
			// Changing this value causes PgBouncer to restart.
			port?: int & >=1024 | *5432

			// Priority class name for the pgBouncer pod. Changing this value
			// causes PostgreSQL to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
			priorityClassName?: string

			// Number of desired PgBouncer pods.
			replicas?: int & >=0 | *1

			// Compute resources of a PgBouncer container. Changing this value
			// causes PgBouncer to restart. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers
			resources?: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// Specification of the service that exposes PgBouncer.
			service?: {
				// Metadata contains metadata for custom resources
				metadata?: {
					annotations?: {
						[string]: string
					}
					labels?: {
						[string]: string
					}
				}

				// The port on which this service is exposed when type is NodePort
				// or LoadBalancer. Value must be in-range and not in use or the
				// operation will fail. If unspecified, a port will be allocated
				// if this Service requires one. -
				// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
				nodePort?: int

				// More info:
				// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
				type?: "ClusterIP" | "NodePort" | "LoadBalancer" | *"ClusterIP"
			}
			sidecars?: {
				pgbouncerConfig?: {
					// Resource requirements for a sidecar container
					resources?: {
						// Limits describes the maximum amount of compute resources
						// allowed. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						limits?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}

						// Requests describes the minimum amount of compute resources
						// required. If Requests is omitted for a container, it defaults
						// to Limits if that is explicitly specified, otherwise to an
						// implementation-defined value. More info:
						// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
						requests?: {
							[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
						}
					}
				}
			}

			// Tolerations of a PgBouncer pod. Changing this value causes
			// PgBouncer to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects. When specified, allowed values are
				// NoSchedule, PreferNoSchedule and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys. If the key is empty, operator must
				// be Exists; this combination means to match all values and all
				// keys.
				key?: string

				// Operator represents a key's relationship to the value. Valid
				// operators are Exists and Equal. Defaults to Equal. Exists is
				// equivalent to wildcard for value, so that a pod can tolerate
				// all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be of effect NoExecute, otherwise this field is
				// ignored) tolerates the taint. By default, it is not set, which
				// means tolerate the taint forever (do not evict). Zero and
				// negative values will be treated as 0 (evict immediately) by
				// the system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to. If the
				// operator is Exists, the value should be empty, otherwise just
				// a regular string.
				value?: string
			}]

			// Topology spread constraints of a PgBouncer pod. Changing this
			// value causes PgBouncer to restart. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
			topologySpreadConstraints?: [...{
				// LabelSelector is used to find matching pods. Pods that match
				// this label selector are counted to determine the number of
				// pods in their corresponding topology domain.
				labelSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// MaxSkew describes the degree to which pods may be unevenly
				// distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the
				// maximum permitted difference between the number of matching
				// pods in the target topology and the global minimum. The global
				// minimum is the minimum number of matching pods in an eligible
				// domain or zero if the number of eligible domains is less than
				// MinDomains. For example, in a 3-zone cluster, MaxSkew is set
				// to 1, and pods with the same labelSelector spread as 2/2/1: In
				// this case, the global minimum is 1. | zone1 | zone2 | zone3 |
				// | P P | P P | P | - if MaxSkew is 1, incoming pod can only be
				// scheduled to zone3 to become 2/2/2; scheduling it onto
				// zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
				// violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be
				// scheduled onto any zone. When
				// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
				// precedence to topologies that satisfy it. It's a required
				// field. Default value is 1 and 0 is not allowed.
				maxSkew: int

				// MinDomains indicates a minimum number of eligible domains. When
				// the number of eligible domains with matching topology keys is
				// less than minDomains, Pod Topology Spread treats "global
				// minimum" as 0, and then the calculation of Skew is performed.
				// And when the number of eligible domains with matching topology
				// keys equals or greater than minDomains, this value has no
				// effect on scheduling. As a result, when the number of eligible
				// domains is less than minDomains, scheduler won't schedule more
				// than maxSkew Pods to those domains. If value is nil, the
				// constraint behaves as if MinDomains is equal to 1. Valid
				// values are integers greater than 0. When value is not nil,
				// WhenUnsatisfiable must be DoNotSchedule.
				// For example, in a 3-zone cluster, MaxSkew is set to 2,
				// MinDomains is set to 5 and pods with the same labelSelector
				// spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P |
				// The number of domains is less than 5(MinDomains), so "global
				// minimum" is treated as 0. In this situation, new pod with the
				// same labelSelector cannot be scheduled, because computed skew
				// will be 3(3 - 0) if new Pod is scheduled to any of the three
				// zones, it will violate MaxSkew.
				// This is an alpha field and requires enabling
				// MinDomainsInPodTopologySpread feature gate.
				minDomains?: int

				// TopologyKey is the key of node labels. Nodes that have a label
				// with this key and identical values are considered to be in the
				// same topology. We consider each <key, value> as a "bucket",
				// and try to put balanced number of pods into each bucket. We
				// define a domain as a particular instance of a topology. Also,
				// we define an eligible domain as a domain whose nodes match the
				// node selector. e.g. If TopologyKey is
				// "kubernetes.io/hostname", each Node is a domain of that
				// topology. And, if TopologyKey is
				// "topology.kubernetes.io/zone", each zone is a domain of that
				// topology. It's a required field.
				topologyKey: string

				// WhenUnsatisfiable indicates how to deal with a pod if it
				// doesn't satisfy the spread constraint. - DoNotSchedule
				// (default) tells the scheduler not to schedule it. -
				// ScheduleAnyway tells the scheduler to schedule the pod in any
				// location, but giving higher precedence to topologies that
				// would help reduce the skew. A constraint is considered
				// "Unsatisfiable" for an incoming pod if and only if every
				// possible node assignment for that pod would violate "MaxSkew"
				// on some topology. For example, in a 3-zone cluster, MaxSkew is
				// set to 1, and pods with the same labelSelector spread as
				// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If
				// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
				// only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
				// ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other
				// words, the cluster can still be imbalanced, but scheduler
				// won't make it *more* imbalanced. It's a required field.
				whenUnsatisfiable: string
			}]
		}
	}

	// Specification of the service that exposes the PostgreSQL
	// primary instance.
	service?: {
		// Metadata contains metadata for custom resources
		metadata?: {
			annotations?: {
				[string]: string
			}
			labels?: {
				[string]: string
			}
		}

		// The port on which this service is exposed when type is NodePort
		// or LoadBalancer. Value must be in-range and not in use or the
		// operation will fail. If unspecified, a port will be allocated
		// if this Service requires one. -
		// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
		nodePort?: int

		// More info:
		// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
		type?: "ClusterIP" | "NodePort" | "LoadBalancer" | *"ClusterIP"
	}

	// Whether or not the PostgreSQL cluster should be stopped. When
	// this is true, workloads are scaled to zero and CronJobs are
	// suspended. Other resources, such as Services and Volumes,
	// remain in place.
	shutdown?: bool

	// Run this cluster as a read-only copy of an existing cluster or
	// archive.
	standby?: {
		// Whether or not the PostgreSQL cluster should be read-only. When
		// this is true, WAL files are applied from a pgBackRest
		// repository or another PostgreSQL server.
		enabled?: bool | *true

		// Network address of the PostgreSQL server to follow via
		// streaming replication.
		host?: string

		// Network port of the PostgreSQL server to follow via streaming
		// replication.
		port?: >=1024 & int

		// The name of the pgBackRest repository to follow for WAL files.
		repoName?: =~"^repo[1-4]"
	}

	// A list of group IDs applied to the process of a container.
	// These can be useful when accessing shared file systems with
	// constrained permissions. More info:
	// https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
	supplementalGroups?: [...int & <=2147483647 & >=1]
	userInterface?: {
		// Defines a pgAdmin user interface.
		pgAdmin: {
			// Scheduling constraints of a pgAdmin pod. Changing this value
			// causes pgAdmin to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node
			affinity?: {
				// Describes node affinity scheduling rules for the pod.
				nodeAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node matches the
					// corresponding matchExpressions; the node(s) with the highest
					// sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// A node selector term, associated with the corresponding weight.
						preference: {
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}

						// Weight associated with matching the corresponding
						// nodeSelectorTerm, in the range 1-100.
						weight: int
					}]
					requiredDuringSchedulingIgnoredDuringExecution?: {
						// Required. A list of node selector terms. The terms are ORed.
						nodeSelectorTerms: [...{
							// A list of node selector requirements by node's labels.
							matchExpressions?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]

							// A list of node selector requirements by node's fields.
							matchFields?: [...{
								// The label key that the selector applies to.
								key: string

								// Represents a key's relationship to a set of values. Valid
								// operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
								operator: string

								// An array of string values. If the operator is In or NotIn, the
								// values array must be non-empty. If the operator is Exists or
								// DoesNotExist, the values array must be empty. If the operator
								// is Gt or Lt, the values array must have a single element,
								// which will be interpreted as an integer. This array is
								// replaced during a strategic merge patch.
								values?: [...string]
							}]
						}]
					}
				}

				// Describes pod affinity scheduling rules (e.g. co-locate this
				// pod in the same node, zone, etc. as some other pod(s)).
				podAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the affinity expressions specified by this field, but
					// it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling affinity expressions, etc.), compute
					// a sum by iterating through the elements of this field and
					// adding "weight" to the sum if the node has pods which matches
					// the corresponding podAffinityTerm; the node(s) with the
					// highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the affinity requirements specified by this field are not
					// met at scheduling time, the pod will not be scheduled onto the
					// node. If the affinity requirements specified by this field
					// cease to be met at some point during pod execution (e.g. due
					// to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}

				// Describes pod anti-affinity scheduling rules (e.g. avoid
				// putting this pod in the same node, zone, etc. as some other
				// pod(s)).
				podAntiAffinity?: {
					// The scheduler will prefer to schedule pods to nodes that
					// satisfy the anti-affinity expressions specified by this field,
					// but it may choose a node that violates one or more of the
					// expressions. The node that is most preferred is the one with
					// the greatest sum of weights, i.e. for each node that meets all
					// of the scheduling requirements (resource request,
					// requiredDuringScheduling anti-affinity expressions, etc.),
					// compute a sum by iterating through the elements of this field
					// and adding "weight" to the sum if the node has pods which
					// matches the corresponding podAffinityTerm; the node(s) with
					// the highest sum are the most preferred.
					preferredDuringSchedulingIgnoredDuringExecution?: [...{
						// Required. A pod affinity term, associated with the
						// corresponding weight.
						podAffinityTerm: {
							// A label query over a set of resources, in this case pods.
							labelSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// A label query over the set of namespaces that the term applies
							// to. The term is applied to the union of the namespaces
							// selected by this field and the ones listed in the namespaces
							// field. null selector and null or empty namespaces list means
							// "this pod's namespace". An empty selector ({}) matches all
							// namespaces.
							namespaceSelector?: {
								// matchExpressions is a list of label selector requirements. The
								// requirements are ANDed.
								matchExpressions?: [...{
									// key is the label key that the selector applies to.
									key: string

									// operator represents a key's relationship to a set of values.
									// Valid operators are In, NotIn, Exists and DoesNotExist.
									operator: string

									// values is an array of string values. If the operator is In or
									// NotIn, the values array must be non-empty. If the operator is
									// Exists or DoesNotExist, the values array must be empty. This
									// array is replaced during a strategic merge patch.
									values?: [...string]
								}]

								// matchLabels is a map of {key,value} pairs. A single {key,value}
								// in the matchLabels map is equivalent to an element of
								// matchExpressions, whose key field is "key", the operator is
								// "In", and the values array contains only "value". The
								// requirements are ANDed.
								matchLabels?: {
									[string]: string
								}
							}

							// namespaces specifies a static list of namespace names that the
							// term applies to. The term is applied to the union of the
							// namespaces listed in this field and the ones selected by
							// namespaceSelector. null or empty namespaces list and null
							// namespaceSelector means "this pod's namespace".
							namespaces?: [...string]

							// This pod should be co-located (affinity) or not co-located
							// (anti-affinity) with the pods matching the labelSelector in
							// the specified namespaces, where co-located is defined as
							// running on a node whose value of the label with key
							// topologyKey matches that of any node on which any of the
							// selected pods is running. Empty topologyKey is not allowed.
							topologyKey: string
						}

						// weight associated with matching the corresponding
						// podAffinityTerm, in the range 1-100.
						weight: int
					}]

					// If the anti-affinity requirements specified by this field are
					// not met at scheduling time, the pod will not be scheduled onto
					// the node. If the anti-affinity requirements specified by this
					// field cease to be met at some point during pod execution (e.g.
					// due to a pod label update), the system may or may not try to
					// eventually evict the pod from its node. When there are
					// multiple elements, the lists of nodes corresponding to each
					// podAffinityTerm are intersected, i.e. all terms must be
					// satisfied.
					requiredDuringSchedulingIgnoredDuringExecution?: [...{
						// A label query over a set of resources, in this case pods.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// A label query over the set of namespaces that the term applies
						// to. The term is applied to the union of the namespaces
						// selected by this field and the ones listed in the namespaces
						// field. null selector and null or empty namespaces list means
						// "this pod's namespace". An empty selector ({}) matches all
						// namespaces.
						namespaceSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn, the values array must be non-empty. If the operator is
								// Exists or DoesNotExist, the values array must be empty. This
								// array is replaced during a strategic merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels map is equivalent to an element of
							// matchExpressions, whose key field is "key", the operator is
							// "In", and the values array contains only "value". The
							// requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// namespaces specifies a static list of namespace names that the
						// term applies to. The term is applied to the union of the
						// namespaces listed in this field and the ones selected by
						// namespaceSelector. null or empty namespaces list and null
						// namespaceSelector means "this pod's namespace".
						namespaces?: [...string]

						// This pod should be co-located (affinity) or not co-located
						// (anti-affinity) with the pods matching the labelSelector in
						// the specified namespaces, where co-located is defined as
						// running on a node whose value of the label with key
						// topologyKey matches that of any node on which any of the
						// selected pods is running. Empty topologyKey is not allowed.
						topologyKey: string
					}]
				}
			}

			// Configuration settings for the pgAdmin process. Changes to any
			// of these values will be loaded without validation. Be careful,
			// as you may put pgAdmin into an unusable state.
			config?: {
				// Files allows the user to mount projected volumes into the
				// pgAdmin container so that files can be referenced by pgAdmin
				// as needed.
				files?: [...{
					// configMap information about the configMap data to project
					configMap?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced ConfigMap will be projected into the volume as
						// a file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the ConfigMap, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional specify whether the ConfigMap or its keys must be
						// defined
						optional?: bool
					}
					downwardAPI?: {
						// Items is a list of DownwardAPIVolume file
						items?: [...{
							// Required: Selects a field of the pod: only annotations, labels,
							// name and namespace are supported.
							fieldRef?: {
								// Version of the schema the FieldPath is written in terms of,
								// defaults to "v1".
								apiVersion?: string

								// Path of the field to select in the specified API version.
								fieldPath: string
							}

							// Optional: mode bits used to set permissions on this file, must
							// be an octal value between 0000 and 0777 or a decimal value
							// between 0 and 511. YAML accepts both octal and decimal values,
							// JSON requires decimal values for mode bits. If not specified,
							// the volume defaultMode will be used. This might be in conflict
							// with other options that affect the file mode, like fsGroup,
							// and the result can be other mode bits set.
							mode?: int

							// Required: Path is the relative path name of the file to be
							// created. Must not be absolute or contain the '..' path. Must
							// be utf-8 encoded. The first item of the relative path must not
							// start with '..'
							path: string

							// Selects a resource of the container: only resources limits and
							// requests (limits.cpu, limits.memory, requests.cpu and
							// requests.memory) are currently supported.
							resourceFieldRef?: {
								// Container name: required for volumes, optional for env vars
								containerName?: string

								// Specifies the output format of the exposed resources, defaults
								// to "1"
								divisor?: (int | string) & {
									=~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
								}

								// Required: resource to select
								resource: string
							}
						}]
					}

					// secret information about the secret data to project
					secret?: {
						// items if unspecified, each key-value pair in the Data field of
						// the referenced Secret will be projected into the volume as a
						// file whose name is the key and content is the value. If
						// specified, the listed keys will be projected into the
						// specified paths, and unlisted keys will not be present. If a
						// key is specified which is not present in the Secret, the
						// volume setup will error unless it is marked optional. Paths
						// must be relative and may not contain the '..' path or start
						// with '..'.
						items?: [...{
							// key is the key to project.
							key: string

							// mode is Optional: mode bits used to set permissions on this
							// file. Must be an octal value between 0000 and 0777 or a
							// decimal value between 0 and 511. YAML accepts both octal and
							// decimal values, JSON requires decimal values for mode bits. If
							// not specified, the volume defaultMode will be used. This might
							// be in conflict with other options that affect the file mode,
							// like fsGroup, and the result can be other mode bits set.
							mode?: int

							// path is the relative path of the file to map the key to. May
							// not be an absolute path. May not contain the path element
							// '..'. May not start with the string '..'.
							path: string
						}]

						// Name of the referent. More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// optional field specify whether the Secret or its key must be
						// defined
						optional?: bool
					}

					// serviceAccountToken is information about the
					// serviceAccountToken data to project
					serviceAccountToken?: {
						// audience is the intended audience of the token. A recipient of
						// a token must identify itself with an identifier specified in
						// the audience of the token, and otherwise should reject the
						// token. The audience defaults to the identifier of the
						// apiserver.
						audience?: string

						// expirationSeconds is the requested duration of validity of the
						// service account token. As the token approaches expiration, the
						// kubelet volume plugin will proactively rotate the service
						// account token. The kubelet will start trying to rotate the
						// token if the token is older than 80 percent of its time to
						// live or if the token is older than 24 hours.Defaults to 1 hour
						// and must be at least 10 minutes.
						expirationSeconds?: int

						// path is the path relative to the mount point of the file to
						// project the token into.
						path: string
					}
				}]

				// A Secret containing the value for the LDAP_BIND_PASSWORD
				// setting. More info:
				// https://www.pgadmin.org/docs/pgadmin4/latest/ldap.html
				ldapBindPassword?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key: string

					// Name of the referent. More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}

				// Settings for the pgAdmin server process. Keys should be
				// uppercase and values must be constants. More info:
				// https://www.pgadmin.org/docs/pgadmin4/latest/config_py.html
				settings?: {
					...
				}
			}

			// Defines a PersistentVolumeClaim for pgAdmin data. More info:
			// https://kubernetes.io/docs/concepts/storage/persistent-volumes
			dataVolumeClaimSpec: {
				// accessModes contains the desired access modes the volume should
				// have. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
				accessModes?: [...string]

				// dataSource field can be used to specify either: * An existing
				// VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
				// * An existing PVC (PersistentVolumeClaim) If the provisioner
				// or an external controller can support the specified data
				// source, it will create a new volume based on the contents of
				// the specified data source. If the AnyVolumeDataSource feature
				// gate is enabled, this field will always have the same contents
				// as the DataSourceRef field.
				dataSource?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// dataSourceRef specifies the object from which to populate the
				// volume with data, if a non-empty volume is desired. This may
				// be any local object from a non-empty API group (non core
				// object) or a PersistentVolumeClaim object. When this field is
				// specified, volume binding will only succeed if the type of the
				// specified object matches some installed volume populator or
				// dynamic provisioner. This field will replace the functionality
				// of the DataSource field and as such if both fields are
				// non-empty, they must have the same value. For backwards
				// compatibility, both fields (DataSource and DataSourceRef) will
				// be set to the same value automatically if one of them is empty
				// and the other is non-empty. There are two important
				// differences between DataSource and DataSourceRef: * While
				// DataSource only allows two specific types of objects,
				// DataSourceRef allows any non-core object, as well as
				// PersistentVolumeClaim objects. * While DataSource ignores
				// disallowed values (dropping them), DataSourceRef preserves all
				// values, and generates an error if a disallowed value is
				// specified. (Beta) Using this field requires the
				// AnyVolumeDataSource feature gate to be enabled.
				dataSourceRef?: {
					// APIGroup is the group for the resource being referenced. If
					// APIGroup is not specified, the specified Kind must be in the
					// core API group. For any other third-party types, APIGroup is
					// required.
					apiGroup?: string

					// Kind is the type of resource being referenced
					kind: string

					// Name is the name of resource being referenced
					name: string
				}

				// resources represents the minimum resources the volume should
				// have. If RecoverVolumeExpansionFailure feature is enabled
				// users are allowed to specify resource requirements that are
				// lower than previous value but must still be higher than
				// capacity recorded in the status field of the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
				resources?: {
					// Limits describes the maximum amount of compute resources
					// allowed. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					limits?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}

					// Requests describes the minimum amount of compute resources
					// required. If Requests is omitted for a container, it defaults
					// to Limits if that is explicitly specified, otherwise to an
					// implementation-defined value. More info:
					// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
					requests?: {
						[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
					}
				}

				// selector is a label query over volumes to consider for binding.
				selector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// storageClassName is the name of the StorageClass required by
				// the claim. More info:
				// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
				storageClassName?: string

				// volumeMode defines what type of volume is required by the
				// claim. Value of Filesystem is implied when not included in
				// claim spec.
				volumeMode?: string

				// volumeName is the binding reference to the PersistentVolume
				// backing this claim.
				volumeName?: string
			}

			// Name of a container image that can run pgAdmin 4. Changing this
			// value causes pgAdmin to restart. The image may also be set
			// using the RELATED_IMAGE_PGADMIN environment variable. More
			// info: https://kubernetes.io/docs/concepts/containers/images
			image?: string

			// Metadata contains metadata for custom resources
			metadata?: {
				annotations?: {
					[string]: string
				}
				labels?: {
					[string]: string
				}
			}

			// Priority class name for the pgAdmin pod. Changing this value
			// causes pgAdmin to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
			priorityClassName?: string

			// Number of desired pgAdmin pods.
			replicas?: int & <=1 & >=0 | *1

			// Compute resources of a pgAdmin container. Changing this value
			// causes pgAdmin to restart. More info:
			// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers
			resources?: {
				// Limits describes the maximum amount of compute resources
				// allowed. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				limits?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}

				// Requests describes the minimum amount of compute resources
				// required. If Requests is omitted for a container, it defaults
				// to Limits if that is explicitly specified, otherwise to an
				// implementation-defined value. More info:
				// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
				requests?: {
					[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
				}
			}

			// Specification of the service that exposes pgAdmin.
			service?: {
				// Metadata contains metadata for custom resources
				metadata?: {
					annotations?: {
						[string]: string
					}
					labels?: {
						[string]: string
					}
				}

				// The port on which this service is exposed when type is NodePort
				// or LoadBalancer. Value must be in-range and not in use or the
				// operation will fail. If unspecified, a port will be allocated
				// if this Service requires one. -
				// https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
				nodePort?: int

				// More info:
				// https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
				type?: "ClusterIP" | "NodePort" | "LoadBalancer" | *"ClusterIP"
			}

			// Tolerations of a pgAdmin pod. Changing this value causes
			// pgAdmin to restart. More info:
			// https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration
			tolerations?: [...{
				// Effect indicates the taint effect to match. Empty means match
				// all taint effects. When specified, allowed values are
				// NoSchedule, PreferNoSchedule and NoExecute.
				effect?: string

				// Key is the taint key that the toleration applies to. Empty
				// means match all taint keys. If the key is empty, operator must
				// be Exists; this combination means to match all values and all
				// keys.
				key?: string

				// Operator represents a key's relationship to the value. Valid
				// operators are Exists and Equal. Defaults to Equal. Exists is
				// equivalent to wildcard for value, so that a pod can tolerate
				// all taints of a particular category.
				operator?: string

				// TolerationSeconds represents the period of time the toleration
				// (which must be of effect NoExecute, otherwise this field is
				// ignored) tolerates the taint. By default, it is not set, which
				// means tolerate the taint forever (do not evict). Zero and
				// negative values will be treated as 0 (evict immediately) by
				// the system.
				tolerationSeconds?: int

				// Value is the taint value the toleration matches to. If the
				// operator is Exists, the value should be empty, otherwise just
				// a regular string.
				value?: string
			}]

			// Topology spread constraints of a pgAdmin pod. Changing this
			// value causes pgAdmin to restart. More info:
			// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
			topologySpreadConstraints?: [...{
				// LabelSelector is used to find matching pods. Pods that match
				// this label selector are counted to determine the number of
				// pods in their corresponding topology domain.
				labelSelector?: {
					// matchExpressions is a list of label selector requirements. The
					// requirements are ANDed.
					matchExpressions?: [...{
						// key is the label key that the selector applies to.
						key: string

						// operator represents a key's relationship to a set of values.
						// Valid operators are In, NotIn, Exists and DoesNotExist.
						operator: string

						// values is an array of string values. If the operator is In or
						// NotIn, the values array must be non-empty. If the operator is
						// Exists or DoesNotExist, the values array must be empty. This
						// array is replaced during a strategic merge patch.
						values?: [...string]
					}]

					// matchLabels is a map of {key,value} pairs. A single {key,value}
					// in the matchLabels map is equivalent to an element of
					// matchExpressions, whose key field is "key", the operator is
					// "In", and the values array contains only "value". The
					// requirements are ANDed.
					matchLabels?: {
						[string]: string
					}
				}

				// MaxSkew describes the degree to which pods may be unevenly
				// distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the
				// maximum permitted difference between the number of matching
				// pods in the target topology and the global minimum. The global
				// minimum is the minimum number of matching pods in an eligible
				// domain or zero if the number of eligible domains is less than
				// MinDomains. For example, in a 3-zone cluster, MaxSkew is set
				// to 1, and pods with the same labelSelector spread as 2/2/1: In
				// this case, the global minimum is 1. | zone1 | zone2 | zone3 |
				// | P P | P P | P | - if MaxSkew is 1, incoming pod can only be
				// scheduled to zone3 to become 2/2/2; scheduling it onto
				// zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
				// violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be
				// scheduled onto any zone. When
				// `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher
				// precedence to topologies that satisfy it. It's a required
				// field. Default value is 1 and 0 is not allowed.
				maxSkew: int

				// MinDomains indicates a minimum number of eligible domains. When
				// the number of eligible domains with matching topology keys is
				// less than minDomains, Pod Topology Spread treats "global
				// minimum" as 0, and then the calculation of Skew is performed.
				// And when the number of eligible domains with matching topology
				// keys equals or greater than minDomains, this value has no
				// effect on scheduling. As a result, when the number of eligible
				// domains is less than minDomains, scheduler won't schedule more
				// than maxSkew Pods to those domains. If value is nil, the
				// constraint behaves as if MinDomains is equal to 1. Valid
				// values are integers greater than 0. When value is not nil,
				// WhenUnsatisfiable must be DoNotSchedule.
				// For example, in a 3-zone cluster, MaxSkew is set to 2,
				// MinDomains is set to 5 and pods with the same labelSelector
				// spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P |
				// The number of domains is less than 5(MinDomains), so "global
				// minimum" is treated as 0. In this situation, new pod with the
				// same labelSelector cannot be scheduled, because computed skew
				// will be 3(3 - 0) if new Pod is scheduled to any of the three
				// zones, it will violate MaxSkew.
				// This is an alpha field and requires enabling
				// MinDomainsInPodTopologySpread feature gate.
				minDomains?: int

				// TopologyKey is the key of node labels. Nodes that have a label
				// with this key and identical values are considered to be in the
				// same topology. We consider each <key, value> as a "bucket",
				// and try to put balanced number of pods into each bucket. We
				// define a domain as a particular instance of a topology. Also,
				// we define an eligible domain as a domain whose nodes match the
				// node selector. e.g. If TopologyKey is
				// "kubernetes.io/hostname", each Node is a domain of that
				// topology. And, if TopologyKey is
				// "topology.kubernetes.io/zone", each zone is a domain of that
				// topology. It's a required field.
				topologyKey: string

				// WhenUnsatisfiable indicates how to deal with a pod if it
				// doesn't satisfy the spread constraint. - DoNotSchedule
				// (default) tells the scheduler not to schedule it. -
				// ScheduleAnyway tells the scheduler to schedule the pod in any
				// location, but giving higher precedence to topologies that
				// would help reduce the skew. A constraint is considered
				// "Unsatisfiable" for an incoming pod if and only if every
				// possible node assignment for that pod would violate "MaxSkew"
				// on some topology. For example, in a 3-zone cluster, MaxSkew is
				// set to 1, and pods with the same labelSelector spread as
				// 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If
				// WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
				// only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as
				// ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other
				// words, the cluster can still be imbalanced, but scheduler
				// won't make it *more* imbalanced. It's a required field.
				whenUnsatisfiable: string
			}]
		}
	}

	// Users to create inside PostgreSQL and the databases they should
	// access. The default creates one user that can access one
	// database matching the PostgresCluster name. An empty list
	// creates no users. Removing a user from this list does NOT drop
	// the user nor revoke their access.
	users?: [...{
		// Databases to which this user can connect and create objects.
		// Removing a database from this list does NOT revoke access.
		// This field is ignored for the "postgres" user.
		databases?: [...strings.MaxRunes(63) & strings.MinRunes(1)]

		// The name of this PostgreSQL user. The value may contain only
		// lowercase letters, numbers, and hyphen so that it fits into
		// Kubernetes metadata.
		name: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
		}

		// ALTER ROLE options except for PASSWORD. This field is ignored
		// for the "postgres" user. More info:
		// https://www.postgresql.org/docs/current/role-attributes.html
		options?: =~"^[^;]*$"
		password?: {
			// Type of password to generate. Defaults to ASCII. Valid options
			// are ASCII and AlphaNumeric. "ASCII" passwords contain letters,
			// numbers, and symbols from the US-ASCII character set.
			// "AlphaNumeric" passwords contain letters and numbers from the
			// US-ASCII character set.
			type: "ASCII" | "AlphaNumeric" | *"ASCII"
		}
	}]
}
